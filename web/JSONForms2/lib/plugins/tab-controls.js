(function (global, factory) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory(require('lodash-4'), require('jquery-2'), require('jf.ui'), require('select2-4'), require('jf.utils'), require('tbjson.jsonpointer'), require('tbjson.ajv2tb'));
  } else if (typeof define === 'function' && define.amd) {
    define(['lodash-4', 'jquery-2', 'jf.ui', 'select2-4', 'jf.utils', 'tbjson.jsonpointer', 'tbjson.ajv2tb'], function () {
      return factory.apply(factory, arguments);
    });
  } else {
    factory(global._, global.jQuery, global.TB.jf.ui, undefined, global.TB.jf.utils, global.TB.tbjson.jsonpointer, global.TB.tbjson.ajv2tb);
  }
})(this, function (_, jQuery, jf, someSelectUnused, jfUtils, tbjsonJsonpointer, tbjsonAjv2TB) {
  var jfUi = jf;
  /**
   * Initializes tabular sections in forms. Such sections are generated by the
   * 'selectfieldset' type of elements in JSON Form.
   *
   * Input fields that are not visible are automatically disabled
   * not to appear in the submitted form. That's on purpose, as tabs
   * are meant to convey an alternative (and not a sequence of steps).
   *
   * The tabs menu is not rendered as tabs but rather as a select field because
   * it's easier to grasp that it's an alternative.
   *
   * Code based on bootstrap-tabs.js, updated to:
   * - react to option selection instead of tab click
   * - disable input fields in non visible tabs
   * - disable the possibility to have dropdown menus (no meaning here)
   * - act as a regular function instead of as a jQuery plug-in.
   *
   * @function
   * @param {Object} tabs jQuery object that contains the tabular sections
   *  to initialize. The object may reference more than one element.
   */
  var activateInitializeTabs = function (element, container, {instantChange = false} = {}) {
    container
      .find('> .active')
      .removeClass('active')
      .removeClass('in');

    element.addClass('active in');
  }

  function checkIfContentIsPopulated(content) {
    let contentKeys = Object.keys(content);
    for (var i = 0; i < contentKeys.length; i++) {
      let key = contentKeys[i];
      if (key == "anyOfId") continue;

      let contentValue = content[key];
      let res;

      if (_.isPlainObject(contentValue)) {
        res = checkIfContentIsPopulated(contentValue);
      } else {
        res = contentValue != null;
      }

      if (res) {
        return true;
      }
    }
  }

  var enableFieldsInitializeTabs = function ($target, targetIndex) {

    var jfType = $target.closest('[data-tb-jf-type]').attr('data-tb-jf-type');

    if (jfType === 'selectfieldset') {

      // Enable all fields in the targeted tab
      $target.find('input, textarea, select').not("[readonly='readonly']").removeAttr('disabled');
      $target.find('[data-tb-jf-type]').not("[readonly='readonly']").removeClass('tb-jf-disabled');
      

      // Disable all fields in other tabs
      $target.siblings(':not([data-idx=' + targetIndex + '])')
        .find('input, textarea, select')
        .attr('disabled', 'disabled');


      $target.siblings(':not([data-idx=' + targetIndex + '])').find('[data-tb-jf-type]').addClass('tb-jf-disabled');
    }
  }


  var optionSelectedInitializeTabs = function (e, extraData) {
    var $select = $(this);
    // var $option = $('option:selected', $select);
    var targetIdx = $select[0].selectize.items[0]; //$option.get(0).getAttribute('data-idx') || $option.attr('value');
    var $target;

    e.preventDefault();

    $target = $select.parents('.tabbable').eq(0).find('> .tab-content > [data-idx=' + targetIdx + ']');

    if ($target.hasClass('active')) {
      return;
    }

    // activateInitializeTabs($option, $select, extraData);
    activateInitializeTabs($target, $target.parent(), extraData);
    enableFieldsInitializeTabs($target, targetIdx);

  }

  var tabClickedInitializeTabs = function (e) {
    var begin_time = Date.now();

    var $this = $(this);
    var $content = $this.parents('.tabbable').first()
      .find('.tab-content').first();
    var targetIdx = $this.index();
    var $target = $content.find('> .tab-pane[data-idx=' + targetIdx + ']');
    // var $firstTab = $target.find('> [data-idx=' + targetIdx + ']');

    var $treeRoot = $this.parents('#tb-jfp-form');
    var jfTree = $treeRoot.data('jfFormTree');

    let currentSelectedElementNode = $this.data('currentNode'); // let!

    var $source = $this.parent().children('.active.in');
    var sourceIdx = $source.index();
    var sourceSelectedElementNode = $source.data('currentNode');

    if (
      e.originalEvent
      && $(this).closest('[data-tb-jf-type]').data('tb-jf-type') == 'selectfieldset'
      && ! $this.is($source)
    ) {
      let data = sourceSelectedElementNode.getFormValues();
      let originalData = jfUtils.getObjByKey(sourceSelectedElementNode.ownerTree.formDesc.content, '/' + sourceSelectedElementNode.key);

      let contentIsPopulated = checkIfContentIsPopulated(data);
      if (originalData != undefined || sourceSelectedElementNode.hasUserInputChanges) {
        if ( ! confirm('Are you sure you want to switch tabs? Choosing OK will DELETE previous tab data on save!') ) {
          return;
        }
      }

      // alarm: fbf53 
      var anyOfId = currentSelectedElementNode.formElement.anyOfId;
      if (anyOfId) {
        let prefixGoodKey = currentSelectedElementNode.parentNode.key.split('/').filter(e => { return e }).join('/');
        $(currentSelectedElementNode.parentNode.el).find(`[name="${prefixGoodKey}/anyOfId"]`).val(anyOfId);
      }
    }
    
    // alarm: fbf53  
    var anyOfId = currentSelectedElementNode.formElement.anyOfId;
    if (anyOfId) {
      let prefixGoodKey = currentSelectedElementNode.parentNode.key.split('/').filter(e => { return e }).join('/');
      $(currentSelectedElementNode.parentNode.el).find(`[name="${prefixGoodKey}/anyOfId"]`).val(anyOfId);
    }

 

    $(currentSelectedElementNode.el).on('change input', function (e, type) {
      if ( type === 'jf-triggered' ) {

      } else {
        currentSelectedElementNode.hasUserInputChanges = true;
      }
    });

    e.preventDefault();
    activateInitializeTabs($this, $this.parent());
    activateInitializeTabs($target, $target.parent());

    $this.parent().parent().parent().parent().parent().attr('active-idx', targetIdx);
    // activate($firstTab, $firstTab.parent());
    enableFieldsInitializeTabs($target, targetIdx);

    // validate only once...
    currentSelectedElementNode.enhance();

    var end_time = Date.now();

    console.log("\t\tTime Delta tabClickedInitializeTabs: ", end_time - begin_time);
  }

  var globalInitializeTabs = function (node) {
    var tree = node.ownerTree;

    if (tree.tabsInitialized) {
      return;
    }
    tree.tabsInitialized = true;

    var $root = $(tree.domRoot);

    $root.each(function () {
      var $this = $(this);
      $this.on('change', 'select.nav', optionSelectedInitializeTabs);
      $this.on('click', 'ul.nav li', tabClickedInitializeTabs);
    });

    // skip actually cliking on tabobjects, saves like 5x time in the initializeTabs function ...
    // $root.find('ul.nav li.active').not('.active2').click();
  }

  var generateTabs = function (node, {selIdx, insertAtElement, isArray, eventHandlers = {}, openDropdown } = {}) {
    ASSERT(insertAtElement && insertAtElement.length == 1);
    ASSERT(node);

    globalInitializeTabs(node);

    var $nodeid = $(node.el).parent().find('#' + jfUtils.escapeSelector(node.id));

    if (selIdx === undefined) {
      selIdx = $nodeid.find('> .tabbable > .tab-content > .active').data('idx');
      if (selIdx) {
        selIdx = parseInt(selIdx, 10);
      } else {
        selIdx = 0;
      }
    }

    if (selIdx >= node.children.length) {
      selIdx = node.children.length - 1;
    }

    var arrayLimits = node.getArrayLimits();

    $(insertAtElement).html('');
    var tabs = node.isTabSelect ? '<select class="nav"></select>' : $(insertAtElement);
    var $tabs = $(tabs);

    _.each(node.children, function (child, idx) {
      var title = child.getTitle() || ((isArray ? 'Item ' : 'Tab ') + (idx + 1));

      var enumerate = child.currentCounterArray.join('.');
      var value = !_.isNil(child.value) ? child.value : idx;
      var active = (idx == selIdx); // child.active

      var $item;
      if (node.isTabSelect) {
        $item = $(`
          <option
            data-idx="${idx}"
            value="${idx}"
            style="${child.formElement.type === 'hidden' ? 'display: none;' : ''}"
            class="${active ? 'active' : ''}"
            data-data="${_.escape(JSON.stringify({enumerate, title, isOrig: child.active}))}"
            data-value="${idx}"
            data-selectable
          >
          ${title}
          </option>
        `);
        
        $item.data('current-node', child);
      } else {
        $item = $(`
          <li
            data-idx="${idx}"
            class="${active ? ' in active2 active ' : ''}"
            value="${_.escape(value)}"
            style="${child.formElement.type === 'hidden' ? 'display: none;' : ''}"
          >
            <a
              ` /* +  `data-toggle="tab"` */ + `
              class="draggable tab ${active ? 'active' : ''}"
              class="tb-jf-enumerate-form"
            >
              <input type="radio" class="tb-jf-hide tb-jf-selectfieldset-radio-unchecked"> <input type="radio" class="tb-jf-hide tb-jf-selectfieldset-radio-checked" checked>
              <span class="tb-jf-content-title">${title}</span>
              <span class="tb-jf-enumerate-form">${enumerate}</span>
            </a>
          </li>
        `);

        if (isArray && !node.isReadOnly() && node.formElement.enableDeletingItems) {
          $item.find('a').append(`
             <span href="#" class="tb-jf-tab-array-tab-delete btn-default btn-xs btn-danger" data-idx="${idx}" >
              <i
                class="${node.ownerTree.defaultClasses.iconClassPrefix}-remove"
                title="Remove item"
              >
              </i>
            </span>
          `);
        }

        $item.data('current-node', child);
      }

      $tabs.append($item);
    });

    // Add items button
    if (
      isArray &&
      !node.isReadOnly() &&
      node.formElement.enableAddingItems &&
      (arrayLimits.maxItems < 0 || node.children.length < arrayLimits.maxItems)
    ) {
      if (node.isTabSelect) {
        $tabs.append(`
          <option
            data-idx="add"
            value="add"
            data-data="${_.escape(JSON.stringify({enumerate:'', title: (node.formElement.addMoreTitle || 'New')}))}"
            data-value="add"
            data-selectable
          >
          </option>
        `);
      } else {
        $tabs.append(`
          <li data-idx="add">
            <a
              class="tab tb-jf-tab-array-addmore"
              title="${
                node.formElement.addMoreTooltip
                  ? _.escape(node.formElement.addMoreTooltip)
                  : 'Add new item'}"
            >
              <i class="${node.ownerTree.defaultClasses.iconClassPrefix}-plus-sign"></i>
              <span>${(node.formElement.addMoreTitle || 'New')}</span>
            </a>
          </li>
        `);
      }
    }

    node.childrenErrorStates = [];

    if (node.isTabSelect) {
      // i was forced, because jquery can;t append elements to '' element... 
      insertAtElement.html($tabs);
    }

    if (node.isTabSelect) {
      node.childOrigDatas = [];
      var templateFunc = function(data, escape) {
        if (!node.childOrigDatas[data.value]) {
          node.childOrigDatas[data.value] = data;
        }

        var { enumerate, title, isOrig } = { ...node.childOrigDatas[data.value], ...data.data };

        return ('<div ' + (node.childrenErrorStates[data.value] ? ' class="has-error" ' : '') + '>'
          + (
            (isArray && !node.isReadOnly() && node.formElement.enableSorting && !isNaN(data.value))
              ?	`
        <span href="#" class="tb-jf-array-item-move-right btn-default btn-xs" data-idx="${data.value}" >
          <i
            class="${node.ownerTree.defaultClasses.iconClassPrefix}-circle-arrow-down"
            title="Move down"
          >
          </i>
        </span>
        <span href="#" class="tb-jf-array-item-move-left btn-default btn-xs" data-idx="${data.value}" >
          <i
            class="${node.ownerTree.defaultClasses.iconClassPrefix}-circle-arrow-up"
            title="Move up"
          >
          </i>
        </span>
      `
                : ''
              )
              + '<span class="tb-jf-enumerate-form">'
              + escape(enumerate)
              + ': </span>'
              + (data.value === 'add' ? `<i class="${node.ownerTree.defaultClasses.iconClassPrefix}-plus-sign"></i> ` : '')
              + '<span class="tb-jf-content-title">'
              + escape(title)
              + '</span>'
              + (
                (isArray && !node.isReadOnly() && node.formElement.enableDeletingItems && !isNaN(data.value))
                ? `
        <span href="#" class="tb-jf-tab-array-tab-delete btn-default btn-xs btn-danger" data-idx="${data.value}" >
          <i
            class="${node.ownerTree.defaultClasses.iconClassPrefix}-remove"
            title="Remove item"
          >
          </i>
        </span>
      `
                : ''
              )
              // + (isOrig ? '<i class="glyphicon glyphicon-bookmark text-success" style="margin-left: 5px"></i>': '')
              + '</div>');
          };

          var $select = $tabs.selectize({
            render: {
              item: templateFunc,
              option: templateFunc
            },
            allowEmptyOption: false,
            create: false,
            onDropdownClose: function () {

            }
          });
          var selectize = $select[0].selectize;
          node.selectize = selectize;

          // monkey patch to get event before selectize [v0.12.1]
          var originalOnOptionSelect = selectize.onOptionSelect;
          selectize.onOptionSelect = function (evt) {
            let target = $(evt.target);
            TRACE("selectize.OnOptionSelect called in tabSelect");
            if (target.closest('.tb-jf-tab-array-tab-delete').length) {
              deleteClickedItemEvent(undefined, evt, true);
            } else if (target.closest('.tb-jf-array-item-move-left').length) {
              moveItemAheadEvent(undefined, evt)
            } else if (target.closest('.tb-jf-array-item-move-right').length) {
              moveItemBehindEvent(undefined, evt)
            } else if (target.closest('[data-selectable][data-value=add]').length) {
              addItemWrapper();
            } else {
              if (eventHandlers.selectTab) {
                originalOnOptionSelect.apply(selectize, arguments);

                let realEventHandlerTarget = evt.currentTarget;
                var idx = $(realEventHandlerTarget).data('value');
                TRACE("Clicked a tab with idx: " + idx);
                if ( ! _.isUndefined(idx) ) {
                  ASSERT(_.isInteger(idx), idx, typeof idx);
                  eventHandlers.selectTab(idx);
                }
                // eventHandlers.selectTab(idx);
              }
            }
          }
          // same as above
          var originalOnMouseDown = selectize.onMouseDown;
          selectize.onMouseDown = function (evt) {
            let target = evt.target;
            if (target.closest('.tb-jf-array-item-move-left') || target.closest('.tb-jf-array-item-move-right')) {
              return;
            }
            originalOnMouseDown.apply(selectize, arguments);
          }

          // TODO check why this is needed
          selectize.refreshOptions(false);
      } else {
        if (eventHandlers.selectTab) {
          $tabs.closest('ul.nav').on('click', '> li', function (evt) {
            var idx = $(evt.target).data('idx');
            if ( ! _.isUndefined(idx) ) {
              ASSERT(_.isInteger(idx), idx, typeof idx);
              eventHandlers.selectTab(idx);
            }
          });
        }
      }

        var {
          addItem,
          deleteItem,
          updateLegend,
          moveNodeTo
        } = eventHandlers;

        function addItemWrapper() {
          var idx = Number(node.children.length);
          ASSERT(node.key != undefined);

          var event = new CustomEvent('tb_jf_array_item_add', {
            detail: {
              key: node.key.startsWith('/') ? node.key : '/' + node.key,
              idx: node.children.length,
            }
          });
          TRACE("AddItem with idx: " + idx);

          node.ownerTree.domRoot.dispatchEvent(event);

          addItem(idx);
        }

        var addItemEvent = function (item, evt) {
          evt.preventDefault && evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          addItemWrapper();
        };

        var deleteClickedItemEvent = function (item, evt, isOnDropdown) {
          evt.preventDefault && evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          let target = evt.target;

          var idx = $(target).closest('.tb-jf-tab-array-tab-delete').data('idx');
          TRACE("Calling deleteClickedItemEvent with idx: " + idx);

          deleteItem(idx, isOnDropdown);
        };

        var updateLegendEvent = function (item, evt) {
          updateLegend();
          evt.preventDefault && evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
        };

        var moveItemAheadEvent = function (item, evt) {
          let target = evt.target;
          var idx = +$(target).closest('.active.tab-pane').data('idx');

          if (isNaN(idx)) {
            idx = $(target).closest('.tb-jf-array-item-move-left').data('idx');
          }

          TRACE("Calling moveItemAheadEvent with idx: " + idx);

          evt.preventDefault && evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();

          if (idx > 0) {
            moveNodeTo(idx, idx - 1);
            if (target.closest('.selectize-control')) {
              node.selectize.open();
            }
            // updateTabs(idx - 1);
          }
        };

        var moveItemBehindEvent = function (item, evt) {
          let target = evt.target;
          var idx = +$(target).closest('.active.tab-pane').data('idx');
          if (isNaN(idx)) {
            idx = $(target).closest('.tb-jf-array-item-move-right').data('idx');
          }

          evt.preventDefault();
          evt.stopPropagation();

          TRACE("Calling moveItemBehindEvent with idx: " + idx);

          if (idx < node.children.length - 1) {
            moveNodeTo(idx, idx + 1);
            if (target.closest('.selectize-control')) {
              node.selectize.open();
            }
            // updateTabs(idx + 1);
          }
        };

        // drag and drop events
        var itemSortChangeEvent = function (item, evt, ui) {
          if (ui.placeholder.index() === $(item).children().length - 1 &&
            ui.placeholder.prev().data('idx') === 'add'
          ) {
            ui.placeholder.prev().before(ui.placeholder);
          }
        };

        var itemSortStopEvent = function (item, evt, ui) {
          var idx = $(ui.item).data('idx');
          var newIdx = $(ui.item).index();

          if (newIdx < 0) { return; }

          moveNodeTo(idx, newIdx);
        };

        // add item to the end of an array
        $nodeid.find('> .tabbable > .nav-tabs > li > .tb-jf-tab-array-addmore').on('click', function (evt) {
          addItemEvent(this, evt);
        });

        if (!node.initializedGlobalTabHandlers) {
          node.initializedGlobalTabHandlers = true;

          // delete tab on click
          $nodeid.delegate('.tb-jf-tab-array-tab-delete', 'click', function (evt) {
            deleteClickedItemEvent(this, evt);
          });

          // update item legend
          $(node.el).on('legendUpdated', function (evt) {
            updateLegendEvent(this, evt);
          });

          // move ahead (left)
          $nodeid.delegate('> .tabbable .tb-jf-array-item-move-left', 'mousedown', function (evt) {
            moveItemAheadEvent(this, evt);
          });

          // move behind (right)
          $nodeid.delegate('> .tabbable .tb-jf-array-item-move-right', 'mousedown', function (evt) {
            moveItemBehindEvent(this, evt);
          });
        }

        node.initializeEventHandlers = function () {
          var arrayLimits = node.getArrayLimits();
          $nodeid.find('> a.tb-jf-tab-array-addmore')
            .toggleClass('disabled', arrayLimits.maxItems >= 0 && node.children.length >= arrayLimits.maxItems);

          var canDelete = arrayLimits.minItems >= 0 && node.children.length <= arrayLimits.minItems;

          $nodeid.find('.tb-jf-tab-array-tab-delete')
            .toggleClass('disabled', canDelete);

          $nodeid.find('.tb-jf-tab-array-tab-delete')
            .toggle(!canDelete);

          if (
            !node.isTabSelect &&
            !node.isReadOnly() &&
            $(node.el).sortable &&
            node.formElement.enableSorting
          ) {
            $('> .tabbable > .nav-tabs', $nodeid).sortable({
              containment: node.el,
              cancel: '.tb-jf-tab-array-addmore',
              tolerance: 'pointer'
            }).on('sortchange', function (evt, ui) {
              itemSortChangeEvent(this, evt, ui);
            }).on('sortstop', function (evt, ui) {
              itemSortStopEvent(this, evt, ui);
            });
          }
        };

        node.initializeEventHandlers();

        var canDelete = arrayLimits.minItems >= 0 && node.children.length <= arrayLimits.minItems;

        $tabs.find('.tb-jf-array-item-delete').toggle(!canDelete)

        if (node.isTabSelect) {
          $(node.el).find(`.nav .selectize-dropdown-content > [data-value=${selIdx}]`).eq(0).click();
        } else {
          $(node.el).find(`.nav [data-idx=${selIdx}]`).eq(0).click();
        }

        //$('[data-toggle="tab"]', $tabs).eq(selIdx).click();
        // $tabs.trigger('change');

        if (openDropdown) {
          node.selectize.open();
        }
      };

      var showTabChild = function(node, child) {
        if (node.isTabSelect) {
          $(node.el).find(`.nav .selectize-dropdown-content > [data-value=${child.childPos}]`).eq(0).click();
        } else {
          $(node.el).find(`.nav [data-idx=${child.childPos}]`).eq(0).click();
        }
      };

      var showTabChildError = function(node, child) {
        if (node.isTabSelect) {
          node.childrenErrorStates[child.childPos] = true;
          if (node.selectize) {
            node.selectize.clearCache();
            node.selectize.updateOption(child.childPos, node.selectize.options[child.childPos]);
          }
        } else {
          $(node.el).find(`.nav > li[data-idx=${child.childPos}]`).eq(0).addClass('has-error');
        }
      };

      var clearTabErrors = function(node, child) {
        if (node.isTabSelect) {
          node.childrenErrorStates = [];
          if (node.selectize) {
            // we might not be visualized, and not OnInsert called
            node.selectize.clearCache();
            node.selectize.refreshOptions(false);
          }
        } else {
          // this is currently handled by external code, nothing to do here
        }
      };

      /**
       * Escapes selector name for use with jQuery
       *
       * All meta-characters listed in jQuery doc are escaped:
       * http://api.jquery.com/category/selectors/
       *
       * @function
       * @param {String} selector The jQuery selector to escape
       * @return {String} The escaped selector.
       */
      var escapeSelector = function (selector) {
        return selector
          .replace(REGEX.ESCAPE_SELECTOR, '\\$1');
      };

      jfUi.elementTypes['tabobject'] = {
        template: '' +
        '<div id="<%= id %>" data-tb-jf-type="tabobject">' +
        '<div class="tabbable <%= node.formElement.tabClass %> ">' +
        '<h4><%= node.title %> <span class="tb-jf-enumerate-form"><%=enumerationText %></span></h4>' +
        '<% if (node.description) { %>' +
          '<span class="help-block tb-jf-description" style="display: block; margin-bottom: 15px;"><%= node.description %></span>' +
        '<% } %>' +
        '<ul class="nav nav-tabs <%= (node.formElement.justified === true) ? "nav-justified" : "" %>">' +
        '<%= tabs %>' +
        '</ul>' +
        '<div class="tab-content tb-jf-input-fieldset row">' +
        '<%= children %>' +
        '</div>' +
        '</div>' +
        '<div class="tb-jf-password-container tb-jf-error-<%= node.selectorKey %>" data-tb-jf-type="<%= node.formElement.type %>">' +
        '<span class="help-block tb-jf-errortext tb-jf-hide"></span>' +
        '</div>' +
        '</div>',
        compatibleTypes: ['object'],
        // 'compatibleItemTypes': ['object', 'array', 'string', 'number', 'integer', 'boolean'],
        compatibleFormats: [],
        minRowWidth: 'half',
        maxRowWidth: 'full',
        fieldtemplate: false,
        containerField: true,
        isTbTemplate: false,
        getElement: function (el) {
          return $(el).parent().get(0);
        },
        childTemplate: function (inner, parentNode, node) {
          if (node.alreadyLoaded) {
            // rerender from server response makes multiple div
            return inner;
          }

          node.alreadyLoaded = true;
          return '' +
            '<div data-idx="<%= node.childPos %>" class="tab-pane fade ' +
            '<% if (node.active) { %> in active <% } %>">' +
            inner +
            '</div>';
        },
        onBeforeRender: function (data, node) {
          node.isTabSelect = node.formElement.forceTabSelect != null ? node.formElement.forceTabSelect : node.children.length > 20;

          // special case for tabobject - hide the default enum title
          if (node.formElement.notitle === undefined) {
            node.formElement.notitle = true;
          }

          // Before rendering, this function ensures that:
          // 1. direct children have IDs (used to show/hide the tabs contents)
          // 2. the tab to active is flagged accordingly.
          // The active tab is:
          //      the first tab for which there is some value available  -> from @momo: this is nonsence, because we are always "clicking" the first tab anyway ...
          //      OR the first one (default behaviour)
          // 3. the HTML of the select field used to select tabs is exposed in the
          // HTML template data as "tabs"
          if (node.formElement.items && node.formElement.items.length >= 0) {
            _.each(node.formElement.items, function (item) {
              // ASSERT(item.type === 'section', {msg: 'tabobject: only elements with type section can be direct children of a tabobject', code: 2950});
            });
          }

          var children = null;
          var choices = [];
          // select the left margin for the tab content

          // pick the appropriate tab style depending on the form options
          switch (node.formElement.tabPosition) {
            case 'left':
              node.formElement.tabClass = 'tabs-left';
              break;

            case 'right':
              node.formElement.tabClass = 'tabs-right';
              break;

            default:
              node.formElement.tabClass = 'tabs';
          }

          if (node.schemaElement) {
            choices = node.schemaElement['enum'] || [];
          }

          if (node.options) {
            children = _.map(node.options, function (option, idx) {
              var child = node.children[idx];
              if (option instanceof Object) {
                option = _.extend({ node: child }, option);
                option.title = option.title || child.legend || child.title || ('Option ' + (child.childPos + 1));
                option.value = !_.isNil(option.value)
                  ? option.value
                  : !_.isNil(choices[idx])
                  ? choices[idx]
                  : idx;

                return {
                  value: option,
                  title: option
                };
              } else {
                return {
                  title: option,
                  value: !_.isNil(choices[child.childPos])
                  ? choices[child.childPos]
                  : child.childPos,
                  node: child
                };
              }
            });
          } else {
            children = _.map(node.children, function (child, idx) {
              return {
                title: child.legend || child.title || ('Option ' + (child.childPos + 1)),
                value: choices[child.childPos] || child.childPos,
                node: child
              };
            });
          }

          var activeChild = null;
          //  if the form has been submitted use the last active tab
          //  if any of the tabs has an input field with non-default value (declared in form) -> from @momo: this is nonsence
          //  otherwise set the first ta as default
          if (data.value) {
            activeChild = _.find(children, function (child) {
              return (child.value === node.value);
            });
          }

          /*
      if (!activeChild) {
        activeChild = _.find(children, function (child) {
          return child.node.hasNonDefaultValue();
        });
      }
      */

          if (!activeChild) {
            activeChild = children[0];
          }

          activeChild.node.active = true;
          data.value = activeChild.value;

          data.tabs = '';

          return data;
        },
        onInsert: function (evt, node) {
          var $nodeid = $(node.el).parent().find('#' + jfUtils.escapeSelector(node.id));
          // if ($nodeid.length == 0 || $nodeid.length > 1) return;
          ASSERT($nodeid.length == 1);

          function updateTabs() {
            generateTabs(node, {
              insertAtElement: $('> .tabbable > .nav-tabs', $nodeid),
              eventHandlers: {
                updateLegend: updateTabs,
                selectTab: function (idx) {
                  node.children[idx].enhance();
                }
              }
            });
          }

          updateTabs();
        },
        showChild: function(node, child) {
          showTabChild(node, child);
        },
        showChildError: function(node, child) {
          showTabChildError(node, child);
        },
        clearErrors: function(node) {
          clearTabErrors(node);
        }
      };

      function getNodeChildSchemaByFormChildIdx(node, childIdx) {
        var child = node.children[childIdx];
        ASSERT(child);
        var anyOfId = child.formElement.anyOfId;
        ASSERT(anyOfId);
        var anyOfSchema;

        for (var alternative of node.schemaElement.anyOf) {
          ASSERT(
            alternative &&
            alternative.properties &&
            alternative.properties.anyOfId &&
            alternative.properties.anyOfId.enum &&
            alternative.properties.anyOfId.enum.length === 1,
            'anyOf alternatives must have anyOfId property with one possible value'
          );

          if (alternative.properties.anyOfId.enum[0] == anyOfId) {
            anyOfSchema = alternative;
            break;
          }
        }

        return anyOfSchema;
      }

      jfUi.elementTypes['selectfieldset'] = {
        template: '' +
        '<div id="<%= id %>" name="<%= name || node.name %>" data-tb-jf-type="selectfieldset">' +
        '<div class="tabbable <%= node.formElement.tabClass %> ">' +
        '<h4><%= node.title %></h4>' +
        '<ul class="nav nav-tabs <%= (node.formElement.justified === true) ? "nav-justified" : "" %>">' +
        '<%= tabs %>' +
        '</ul>' +
        '<div class="tab-content tb-jf-input-fieldset row">' +
        '<%= children %>' +
        '</div>' +
        '</div>' +
        '</div>',
        compatibleTypes: ['object'],
        // 'compatibleItemTypes': ['object', 'array', 'string', 'number', 'integer', 'boolean'],
        compatibleFormats: [],
        minRowWidth: 'half',
        maxRowWidth: 'full',
        fieldtemplate: false,
        containerField: true,
        isTbTemplate: false,
        getElement: function (el) {
          return $(el).parent().get(0);
        },
        childTemplate: function (inner, parentNode, node) {
          if (node.alreadyLoaded) {
            // rerender from server response makes multiple div
            return inner;
          }

          // TODO @simo add anyOfId select tab

          node.alreadyLoaded = true;
          return '' +
            '<div data-idx="<%= node.childPos %>" class="tab-pane fade ' +
            '<% if (node.active) { %> in active <% } %>">' +
            inner +
            '</div>';
        },
        onBeforeRender: function (data, node) {
          ASSERT(node.formElement.forceTabSelect == null, 'forceTabSelect not supported for selectfieldset');

          // special case for tabobject - hide the default enum title
          if (node.formElement.notitle === undefined) {
            node.formElement.notitle = true;
          }

          // Before rendering, this function ensures that:
          // 1. direct children have IDs (used to show/hide the tabs contents)
          // 2. the tab to active is flagged accordingly.
          // The active tab is:
          //      the first tab for which there is some value available  -> from @momo: this is nonsence, because we are always "clicking" the first tab anyway ...
          //      OR the first one (default behaviour)
          // 3. the HTML of the select field used to select tabs is exposed in the
          // HTML template data as "tabs"
          if (node.formElement.items && node.formElement.items.length >= 0) {
            _.each(node.formElement.items, function (item) {
              // ASSERT(item.type === 'section', {msg: 'tabobject: only elements with type section can be direct children of a tabobject', code: 2950});
            });
          }

          var children = null;
          var choices = [];
          // select the left margin for the tab content

          // pick the appropriate tab style depending on the form options
          switch (node.formElement.tabPosition) {
            case 'left':
              node.formElement.tabClass = 'tabs-left';
              break;

            case 'right':
              node.formElement.tabClass = 'tabs-right';
              break;

            default:
              node.formElement.tabClass = 'tabs';
          }

          if (node.schemaElement) {
            choices = node.schemaElement['enum'] || [];
          }

          if (node.options) {
            children = _.map(node.options, function (option, idx) {
              var child = node.children[idx];
              if (option instanceof Object) {
                option = _.extend({ node: child }, option);
                option.title = option.title || child.legend || child.title || ('Option ' + (child.childPos + 1));
                option.value = !_.isNil(option.value)
                  ? option.value
                  : !_.isNil(choices[idx])
                  ? choices[idx]
                  : idx;

                return {
                  value: option,
                  title: option
                };
              } else {
                return {
                  title: option,
                  value: !_.isNil(choices[child.childPos])
                  ? choices[child.childPos]
                  : child.childPos,
                  node: child
                };
              }
            });
          } else {
            children = _.map(node.children, function (child, idx) {
              return {
                title: child.legend || child.title || ('Option ' + (child.childPos + 1)),
                value: choices[child.childPos] || child.childPos,
                node: child
              };
            });
          }

          var activeChild = null;
          //  if the form has been submitted use the last active tab
          //  if any of the tabs has an input field with non-default value (declared in form) -> from @momo: this is nonsence
          //  otherwise set the first ta as default
          if (data.value) {
            activeChild = _.find(children, function (child) {
              return (child.value === node.value);
            });
          }

          /*
      if (!activeChild) {
        activeChild = _.find(children, function (child) {
          return child.node.hasNonDefaultValue();
        });
      }
      */
          if (node.ownerTree.formDesc.content && node.schemaElement && node.formElement && node.schemaElement.anyOf) {
            activeChild = _.find(children, function (child) {
                if (child.node.anyOfIds) {
                  return (child.node.anyOfIds[0] === _.get(node.ownerTree.formDesc.content[node.formElement.key], 'anyOfId'));
                }
                return false;
            });
          }

          if (!activeChild) {
            activeChild = children[0];
            ASSERT(activeChild, {children});
          }

          activeChild.node.active = true;
          data.value = activeChild.value;

          data.tabs = '';

          return data;
        },
        onInsert: function (evt, node) {
          var $nodeid = $(node.el).parent().find('#' + jfUtils.escapeSelector(node.id));
          // if ($nodeid.length == 0 || $nodeid.length > 1) return;
          ASSERT($nodeid.length == 1);

          ASSERT(node.key != null, node);
          var contentAnyOfId = node.ownerTree.formDesc.content && _.get(node.ownerTree.formDesc.content, `${node.key}/anyOfId`.split('/').filter(c=>c) );

          function updateTabs(selIdx) {
            generateTabs(node, {
              // TODO this first may cause problems,
              insertAtElement: $('> .tabbable > .nav-tabs', $nodeid),
              selIdx,
              eventHandlers: {
                updateLegend: updateTabs,
                selectTab: function (idx) {
                  // var anyOfSchema = getNodeChildSchemaByFormChildIdx(node, activeIdx);

                  // var anyOfId = node.children[idx].formElement.anyOfId;

                  // $(node.el).find(`[name="${node.key}/anyOfId"]`).val(anyOfId);

                  // Selecting another tab should trigger jf change
                  $(node.el).trigger('change');

                  // node.ownerTree.anyOfIds = [anyOfId];
                }
              }
            });
          }

          if (contentAnyOfId) {
            for (var [i, child] of node.children.entries()) {
              if (child.formElement.anyOfId == contentAnyOfId) {
                updateTabs(i);
              }
            }
          } else {
            updateTabs();
          }

        },
        getErrors: function(node) {
          // TODO check if it works with tab select
          var $activeEl = $(node.el).find('.nav-tabs').first().find('li.active');
          ASSERT($activeEl.length === 1);
          var activeIdx = $activeEl.data('idx');
          ASSERT(_.isInteger(activeIdx));
          var anyOfSchema = getNodeChildSchemaByFormChildIdx(node, activeIdx);
          ASSERT(anyOfSchema);

          ASSERT(anyOfSchema.id);
          var valid = node.ownerTree.formDesc.validator.validate(
            //node.ownerTree.formDesc.schema.id + anyOfSchema.id,
            anyOfSchema,
            jfUtils.forceValueTypes(node.ownerTree.formDesc.schema, anyOfSchema, jfUtils.getObjByKey(node.children[activeIdx].getFormValues(), '/' + node.key) || jfUtils.getObjByKey(node.children[activeIdx].getFormValues(), node.key))
          );

          if (valid !== true) {
            valid.tbData.validationErrors = valid.tbData.validationErrors.filter(e=>!e.dataPath.endsWith('anyOfId'));
            valid.tbData.validationErrors.forEach(err => {

              err.dataPath = tbjsonAjv2TB.jsonPointerNotationToDotNotation(node.key) + err.dataPath;

              err.domErrorContext = $(node.el).children('.tab-content > .tab-pane.active').get(0);
            });

            return valid.tbData.validationErrors;
          }

          return false;
        },
        showChild: function(node, child) {
          showTabChild(node, child);
        },
        showChildError: function(node, child) {
        },
        clearErrors: function(node) {
          clearTabErrors(node);
        }
      };


      jfUi.elementTypes['tabarray'] = {
        template: '' +
        '<div id="<%= id %>">' +
        '<div class="tabbable tabs-left">' +
        '<ul name="<%= name || node.name %>" class="nav nav-tabs <%= (node.formElement.justified === true) ? "nav-justified" : "" %>">' +
        '<%= tabs %>' +
        '</ul>' +
        '<div class="tab-content tb-jf-input-fieldset row">' +
        '<%= children %>' +
        '</div>' +
        '</div>' +
        '</div>',
        compatibleTypes: ['array'],
        // 'compatibleItemTypes': ['string', 'number', 'integer', 'boolean'],
        compatibleFormats: [],
        minRowWidth: 'half',
        maxRowWidth: 'full',
        fieldtemplate: true,
        containerField: true,
        array: true,
        isArrayContainer: true, // to replace `array` property
        isTbTemplate: false,
        getFieldValue: function (rootNode, tree) {
          ASSERT(tree);

          var $indexList = $(rootNode).children('div').children('div').children('div').children('ul');
          var name = $indexList.closest('[data-tb-jf-type="tabarray"]').attr('name');
          var node = tree.keyToNode[$(rootNode).attr('name')];

          // Data not innited
          if ( ! $(rootNode).attr('tb-jf-inserted-at-called') ) {
            return {
              'name': name,
              'value': _.cloneDeep( tbjsonJsonpointer.get(tree.formDesc._originalContent, tbjsonAjv2TB.jsonformPointerToJsonPointer(node.key)) ),
            }
          }

          var $indexListChildren = node.isTabSelect ? $indexList.children('select').children('option') : $indexList.children('li');
          if ($indexListChildren.length === 0 || $indexListChildren.length === 1 && ($($indexListChildren[0]).attr('data-idx') === 'add' || $indexListChildren.val() === 'add')) {
            return {
              'name': name,
              'value': jfUtils.getEmptyArrayValue(node.schemaElement.type, tbjsonJsonpointer.get(tree.formDesc._originalContent, '/' + node.key))
            }
          }
        },
        childTemplate: function (inner, node, childNode) {
          var isActiveClass = "";
          if (node.isTabSelect && childNode.childPos === 0) {
            isActiveClass = "active in";
          }

          var template = '<div data-idx="<%= node.childPos %>" class="tab-pane fade ' + isActiveClass + '" data-tb-jf-type="tabarray-item">';

          if (!node.isReadOnly() && node.formElement.enableSorting) {
            template += ' <span class="tb-jf-tab-array-button-group">' +
              ' <a class="<%= cls.buttonClass %> tb-jf-array-item-move-left btn-xs"><i class="<%= cls.iconClassPrefix %>-circle-arrow-left" title="Remove item"></i>';
            if (node.formElement.displaySystemButtonsLabels) {
              template += ' move left';
            }
            template += '</a>';

            template += ' <a class="<%= cls.buttonClass %> tb-jf-array-item-move-right btn-xs"><i class="<%= cls.iconClassPrefix %>-circle-arrow-right" title="Remove item"></i>';
            if (node.formElement.displaySystemButtonsLabels) {
              template += ' move right';
            }
            template += '</a> </span>';
          }

          template += inner +
            '</div>';

          return template;
        },
        onBeforeRender: function (data, node) {
          node.isTabSelect = node.formElement.forceTabSelect != null ? node.formElement.forceTabSelect : node.children.length > 20;

          if (node.formElement.items && node.formElement.items.length >= 0) {
            _.each(node.formElement.items, function (item) {
              ASSERT(item.type === 'section', { msg: 'tabarray: only elements with type section can be direct children of a tabarray' });
            });
          }

          data.tabs = '';
        },
        onInsert: function (evt, node) {
          var $nodeid = $(node.el).find('#' + jfUtils.escapeSelector(node.id));
          $nodeid.closest('[data-tb-jf-type]').attr('tb-jf-inserted-at-called', 1);
          var arrayLimits = node.getArrayLimits();

          var moveNodeTo = function (fromIdx, toIdx) {
            // Note "switchValuesWithNode" extracts values from the DOM since field
            // values are not synchronized with the tree data structure, so calls
            // to render are needed at each step to force values down to the DOM
            // before next move.
            // TODO: synchronize field values and data structure completely and
            // call render only once to improve efficiency.
            fromIdx = Number(fromIdx);
            toIdx = Number(toIdx);
            if (fromIdx === toIdx) {
              return;
            }
            var incr = (fromIdx < toIdx) ? 1 : -1;
            var tabEl = $('> .tabbable > .tab-content', $nodeid).get(0);

            for (var i = fromIdx; i !== toIdx; i += incr) {
              node.children[i].switchValuesWithNode(node.children[i + incr]);
              node.shouldEnhanceFunc();
              console.info("Calling Render 4: from the moveNodeTo tabarray ");

              /*
          node.children[i].render(tabEl);
          node.children[i + incr].render(tabEl);

          node.children[i].markChildEventHandlersForUpdate();
          node.children[i + incr].markChildEventHandlersForUpdate();
          */

              node.children[i].shouldEnhanceFunc();
              node.children[i].render(tabEl);

              node.children[i + incr].shouldEnhanceFunc();
              node.children[i + incr].render(tabEl);
            }

            $nodeid.trigger('change', ['jf-triggered']);
            updateTabs(toIdx);
          };

          // Refreshes the list of tabs
          var updateTabs = function (selIdx, openDropdown) {
            generateTabs(node, {
              isArray: true,
              selIdx,
              insertAtElement: $('> .tabbable > .nav-tabs', $nodeid),
              eventHandlers: {
                addItem,
                deleteItem,
                updateLegend,
                moveNodeTo,
                selectTab: function (idx) {
                  console.log("TABARRAY SELECTTAB clicked: ", idx);
                  node.children[idx].enhance();
                }
              },
              openDropdown
            });
          };

          var deleteItem = function (idx, openDropdown) {
            var itemNumCanDelete = node.children.length - Math.max(arrayLimits.minItems, 0) - 1;

            $nodeid.find('.tb-jf-tab-array-tab-delete')
              .toggle(itemNumCanDelete > 0);

            if ( itemNumCanDelete < 0 ||
              node.formElement.enableDeletingItems !== true) {
              return false;
            }

            node.deleteArrayItem(idx);

            //updateTabs();
            updateTabs(undefined, openDropdown);

            $nodeid.find('> a.tb-jf-tab-array-addmore')
              .toggleClass('disabled', arrayLimits.maxItems >= 0 && node.children.length >= arrayLimits.maxItems);

            $nodeid.trigger('change');
          };

          var addItem = function (idx) {
            if (node.formElement.enableAddingItems !== true) {
              return false;
            }

            if (arrayLimits.maxItems >= 0) {
              var slotNum = arrayLimits.maxItems - node.children.length;
              $nodeid.find('> a.tb-jf-tab-array-addmore')
                .toggleClass('disabled', slotNum <= 1);
              if (slotNum < 1) {
                return false;
              }
            }

            node.insertArrayItem(
              idx,
              $nodeid.find('> .tabbable > .tab-content').get(0)
            );
            updateTabs(idx);

            $nodeid.find('.tb-jf-tab-array-tab-delete')
              .toggleClass('disabled', node.children.length <= arrayLimits.minItems);

            $nodeid.trigger('change');
          };

          var updateLegend = function () {
            updateTabs();
          }

          // satisfy the minItems constraint
          if (arrayLimits.minItems >= 0) {
            for (var i = node.children.length; i < arrayLimits.minItems; i++) {
              addItem(node.children.length);
            }


            // updateTabs(0);
            // Check if it should have an index at all - doesnt work? @momo
            updateTabs();
          } else {
            updateTabs( _.isUndefined(node.currentlySelectedIndex) ? undefined : parseInt(node.currentlySelectedIndex, 10) );
          }
        },
        // similarly to the array template the elements for the lock and unlock functions cannot be cached
        // as new element can be created and old ones can be deleted by the user
        lock: function (node) {
          $(node.el).find('.tb-jf-tab-array-tab-delete')
            .hide();

          $(node.el).find('> div.controls > div > div.tabbable > ul.nav > li[data-idx="add"]')
            .hide();

          $(node.el).find('> div.controls > div > div.tabbable > div.tab-content > div.tab-pane > span.tb-jf-tab-array-button-group')
            .hide();
        },
        unlock: function (node) {
          $(node.el).find('span.tb-jf-tab-array-tab-delete')
            .show();

          $(node.el).find('> div.controls > div > div.tabbable > ul.nav > li[data-idx="add"]')
            .show();

          $(node.el).find('> div.controls > div > div.tabbable > div.tab-content > div.tab-pane > span.tb-jf-tab-array-button-group')
            .show();
        },
        showChild: function(node, child) {
          showTabChild(node, child);
        },
        showChildError: function(node, child) {
          showTabChildError(node, child);
        },
        clearErrors: function(node) {
          clearTabErrors(node);
        }
      };

      jfUi.elementTypes['alternative'] = {
        template: '' +
        '<div id="<%= id %>">' +
        '<div class="tabbable <%= node.formElement.tabClass %> ">' +
        // '<ul class="nav nav-tabs <%= (node.formElement.justified === true) ? "nav-justified" : "" %>">' +
        // '<%= tabs %>' +
        // '</ul>' +
        '<div class="tab-content tb-jf-input-fieldset row">' +
        '<%= children %>' +
        '</div>' +
        '</div>' +
        '</div>',
        minRowWidth: 'half',
        maxRowWidth: 'full',
        fieldtemplate: true,
        isTbTemplate: false,
        compatibleTypes: [],
        childTemplate: function (inner, parent) {
          this.please_send_help_is_even = this.please_send_help_is_even || 0;
          if (this.please_send_help_is_even % 2 === 0) {
            this.please_send_help_is_even++;

            // ASSERT ALL THE THINGS IN THE CONFIG :::::<<<<<<<<<<<<<< PLEASE
            var metaChild = parent.children[0];
            var options = metaChild.options;

            var $resultHtmlContainer = $('<div />');

            var $resultHtml = $('<div />');
            $resultHtml.addClass('tb-jf-alternative-meta');
            $resultHtml.attr('help_prop', metaChild.name);
            $resultHtml.attr('help_prop2', parent.children[1].name);

            for (var i = 0; i < options.length; i++) {
              var option = options[i];
              var id = this.please_send_help_is_even + '_' + i + '_alternatives';

              var $div = $('<span />');

              var $check = $('<input type="checkbox" />');
              $check.val(option.value);
              $check.attr('id', id);
              $div.append($check);

              var $label = $('<label />');
              $label.attr('for', id);
              $label.text(option.value);


              $div.append($label);

              $resultHtml.append($div);
            }
            $resultHtmlContainer.append($resultHtml);

            return $resultHtmlContainer.html();

          } else {

            this.please_send_help_is_even++;
            return '<div class="tb-jf-alternative-real">' + inner + '</div>';

          }
        },
        getFieldValue: function (node, formTree) {
          var $node = $(node);
          var value = {};

          var $container = $node.find('.tb-jf-alternative-meta');

          var metaName = $container.attr('help_prop');
          var realName = $container.attr('help_prop2');
          value.name = metaName;
          value.value = [];

          formTree.removeFieldsFromForm = formTree.removeFieldsFromForm || {};
          formTree.removeFieldsFromForm[realName] = [];
          $container.find('input').each(function(idx) {

            if (this.checked) {
              value.value.push(this.value);
            } else {
              formTree.removeFieldsFromForm[realName].push(this.value);
            }

          });

          return value;
        },
        onInsert: function(evt, node) {
          //initializeTabs($(node.ownerTree.domRoot));
        },
        showChild: function(node, child) {
          // TODO
        }
      };

      window.TAB_CONTROL_JS_INCLUDED = true;
    });

