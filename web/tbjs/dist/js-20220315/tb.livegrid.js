/**
 * @author Ivan Ivanov <ivan.ivanov@telebid-pro.com>
 * @desc Update many DOM items blazingly fast
 * @module Livegrid
 * @memberOf TB
 */
;(function(global, factory) {
  if(typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory(require('d3'), require('tb.xerrors'), require('tb.dispatcher'), require('lodash'));
  } else if (typeof define === 'function' && define.amd) {
    define(['d3', 'tb.xerrors', 'tb.dispatcher', 'lodash'], function() {
      return factory.apply(factory, arguments);
    });
  } else {
    global.TB = global.TB || {};
    global.TB.Livegrid = factory(d3, global.TB, global.TB.Dispatcher, _);
  }
})(this, function(d3, TB, Dispatcher, _) {
  'use strict';
    /**
     * TB.Livegrid plugin
     * @constructor
     * @memberof TB
     * @alias TB.Livegrid
     * @augments Dispatch
     * @param {Object} settings init settings for the plugin
     * @param {( DOMSelector|DOMElement )} settings.element parent element of the plugin
     * @param {( DOMSelector|DOMElement )} settings.menuElement parent element of the menu
     * @param {Object.<String,InitTypeObject>} settings.types definition of types
     * @param {Boolean} [settings.externalControlMenu=false] DEPRECATED see hideInactiveMenu
     * @param {Boolean} [settings.hideInactiveMenu=false] do not show inactive menu
     * @param {Boolean} [settings.menuItems=['save', 'edit', 'resize', 'zoom', 'opacity']] if empty array or defined falsable value, do not show menu in active mode at all, else it's array of strings, explaining order and type of menu items. Possible values: 'zoom', 'resize', 'cancel', 'save', 'opacity'
     * @param {String} [settings.prefixClassName='tb-lg-class-'] prefix of all autogenerated class names
     * @param {?Object} settings.CSSJSON extend default tb.livegrid.css
     * @param {?String} settings.backgroundImage background image settings
     * @param {?String} settings.backgroundImage.src background image src
     * @param {?String} settings.backgroundImage.width background image width
     * @param {?String} settings.backgroundImage.height background image height
     * @param {?Object} settings.grid if falsable value, there is no grid
     * @param {Boolean} [settings.grid.isEditable=false] whether items are editable ( can be repositioned etc )
     * @param {Boolean} [settings.grid.isEnabled=true] if true, there would be a grid
     * @param {Boolean} [settings.grid.autoscale=false] if true, the grid autoscales to show all elements on the grid
     * @param {Boolean} [settings.grid.autoscaleUnpositionedOnly=true] if true, the grid autoscales only when there are unpositioned items
     * @param {Boolean} [settings.grid.autosize=false] DEPRECATED
     * @param {Boolean} [settings.grid.autoheight=true] set height automatically
     * @param {Boolean} [settings.grid.itemAutoscale=true] scale item's content until it fits
     * @param {Number} [settings.grid.itemWidth=100] width of a single item in pixels
     * @param {Number} [settings.grid.itemHeight=100] height of a single item in pixels
     * @param {Number} [settings.grid.minItemWidth=50] minumum width of a single item in pixels
     * @param {Number} [settings.grid.maxItemWidth=300] maximum width of a single item in pixels
     * @param {Number} [settings.grid.minItemHeight=50] minumum height of a single item in pixels
     * @param {Number} [settings.grid.maxItemHeight=300] maximum height of a single item in pixels
     * @param {Number} [settings.grid.stepZoom=0.1] step zoom level
     * @param {Number} [settings.grid.minZoom=0.1] minimum zoom level
     * @param {Number} [settings.grid.maxZoom=1] maximum zoom level
     * @param {Number} [settings.grid.stepOpacity=0.1] step opacity level
     * @param {Number} [settings.grid.minOpacity=0.5] minimum opacity level
     * @param {Number} [settings.grid.maxOpacity=1] maximum opacity level
     * @param {Number} [settings.grid.disableWheelZoom=false] disable mousewheel zoom
     * @param {Number} [settings.grid.disablePanningInNormalMode=true] enable map panning only in edit mode
     * @param {Number} [settings.grid.itemsBuffer=10] number of spare items from the left and bottom most items
     * @param {Number} [settings.grid.rotateDegStep=15] how many degrees to rotate clockwise on click on grid-item
     * @param {Number} [settings.grid.unpositionedItemsPerRow=20]
     * @param {Number} [settings.grid.unpositionedItemsBuffer=1]
     * @param {Array} [settings.data] block's data
     */
    function Livegrid( settings, data ) {
      if ( !( this instanceof Livegrid ) ) {
        return new Livegrid( settings, data );
      }

      ASSERT.isPlainObject( settings, { code: 'TBJS/LG/2010', msg: 'Expected `settings` to be of type object!', } );
      ASSERT.has( settings, 'element', { code: 'TBJS/LG/2020', msg: 'Expected `settings` to have property `element`', } );
      ASSERT.isPlainObject( settings.types, { code: 'TBJS/LG/2030', msg: 'Expected `settings` to have property `types` of type `object`', } );

      TB.Dispatcher.call( this );

      var defaultSettings = {
        element: null,
        menuElement: null,
        types: null,
        hideInactiveMenu: false,
        menuItems: ['save', 'edit', 'resizeH', 'resizeW', 'zoom', 'opacity', 'snap'],
        prefixClassName: 'tb-lg-class-',
        CSSJSON: TB.merge( {}, this.templates.CSSJSON ),
        backgroundImage: null,
        grid: {
          isEditable: false,
          isEnabled: false,
          autoscale: false,
          autoscaleUnpositionedOnly: true,
          autosize: false,
          itemAutoscale: true,
          itemWidth: 100,
          itemHeight: 100,
          minItemWidth: 50,
          maxItemWidth: 300,
          minItemHeight: 50,
          maxItemHeight: 300,
          stepZoom: 0.1,
          minZoom: 0.1,
          maxZoom: 1,
          opacity: 1,
          stepOpacity: 0.1,
          minOpacity: 0.5,
          maxOpacity: 1,
          itemsBuffer: 10000,
          unpositionedItemsPerRow: 10,
          unpositionedItemsBuffer: 1,
          disableWheelZoom: false,
          rotateDegStep: 15,
          autoheight: true,
          disablePanningInNormalMode: true,
          // snapPrecision: 1,
        },
      };

      var mergedSettings = TB.merge( TB.merge( {}, defaultSettings ), settings );

      if ( settings.menuItems !== undefined ) {
        mergedSettings.menuItems = settings.menuItems;
      }

      /**
       * Keeps d3 selection container element, passed on initialization
       * @name TB.Livegrid#DOMel
       * @type {D3selection}
       */
      this.DOMel = null;
      /**
       * Keeps d3 selection container menu element, passed on initialization
       * @name TB.Livegrid#DOMmenuEl
       * @type {D3selection}
       */
      this.DOMmenuEl = null;
      /**
       * Wraps around blocks and background grid
       * @name TB.Livegrid#DOMwrapper
       * @type {D3selection}
       */
      this.DOMwrapper = null;
      /**
       * Wraps around blocks
       * @name TB.Livegrid#DOMitemsContainer
       * @type {D3selection}
       */
      this.DOMitemsContainer = null;
      /**
       * Navbar
       * @name TB.Livegrid#DOMnavbar
       * @type {D3selection}
       */
      this.DOMnavbar = null;
      /**
       * Edit button
       * @name TB.Livegrid#DOMbtnEdit
       * @type {D3Selection}
       */
      this.DOMbtnEdit = null;
      /**
       * Save button
       * @name TB.Livegrid#DOMbtnSave
       * @type {D3Selection}
       */
      this.DOMbtnSave = null;
      /**
       * Plugin DOM element width
       * @type {Number}
       */
      this.elWidth = null;
      /**
       * Plugin DOM element height
       * @type {Number}
       */
      this.elHeight = null;
      /**
       * Hold—è settings of the plugin
       * @name TB.Livegrid#s
       * @type {Object}
       * @readonly
       */
      this.s = mergedSettings;
      /**
       * Flag is menu is disabled at all
       * @type {Boolean}
       */
      this.disableMenu = ( TB.isArray( this.s.menuItems ) )
        ? !( this.s.menuItems.length )
        : ( ( this.s.menuItems !== undefined )
          ? !!( this.s.menuItems )
          : true
          );
      /**
       * Map of defined block types
       * @name TB.Livegrid#types
       * @type {Object}
       */
      this.types = {};
      /**
       * Ordered CSS rules
       * @name TB.Livegrid#css
       * @type {Array}
       */
      this.css = [];
      /**
       * Objects list
       * @name TB.Livegrid#objList
       * @type {Array}
       */
      this.objList = [];
      /**
       * Objects hash map
       * @name TB.Livegrid#objList
       * @type {Object}
       */
      this.objHash = {};
      /**
       * Grid members holder
       * @name TB.Livegrid#g
       * @type {Object}
       * @property {Boolean} isEnabled grid to be drawn
       * @property {Boolean} editMode is in edit mode
       * @property {Boolean} snapMode is in snap mode, each element can be moved only from cell to cell
       * @property {Number} translateX translate position X axis
       * @property {Number} translateY translate position Y axis
       * @property {Number} minPositionedX minimum X coordinate of all current grid items
       * @property {Number} maxPositionedX maximum X coordinate of all current grid items
       * @property {Number} minPositionedY minimum Y coordinate of all current grid items
       * @property {Number} maxPositionedY maximum Y coordinate of all current grid items
       * @property {Number} colsCount number of grid columns
       * @property {Number} rowsCount number of grid rows
       * @property {Number} itemWidth width of single grid item
       * @property {Number} itemHeight height of single grid item
       * @property {Number} wrapperActiveWidth width of items wrapper (actual width of the whole grid)
       * @property {Number} wrapperActiveHeight width of items wrapper (actual height of the whole grid)
       * @property {Array} unpositionedElements unpositioned items without fixed place on the grid
       * @property {indexTable} indexTable index table for items with fixed coordinates
       * @property {indexTable} indexTableAll index table for items with calculated coordinates
       * @property {indexTable} indexTableSnapshot index table for items with temporary coordinates (in editMode)
       */
      this.g = {
        isEnabled: this.s.grid.isEnabled,
        editMode: false,
        snapMode: true,

        translateX: 0,
        translateY: 0,

        minPositionedX: null,
        maxPositionedX: null,
        minPositionedY: null,
        maxPositionedY: null,

        colsCount: this.s.grid.itemsBuffer,
        rowsCount: this.s.grid.itemsBuffer,

        itemWidth: this.s.grid.itemWidth,
        itemHeight: this.s.grid.itemHeight,

        opacity: this.s.grid.opacity,

        wrapperActiveWidth: null,
        wrapperActiveHeight: null,

        unpositionedElements: [],
        hadUnpositionedElements: false,

        indexTable: [],
        indexTableAll: [],
        indexTableSnapshot: null,
      };
      /**
       * Timeouts map
       * @type {Object}
       */
      this._timeouts = {};
      /**
       * Flag if there is currently dragged item
       * @type {Object}
       */
      this.isDragging = false;



      this._init();


      if ( this.g.isEnabled ) {
        ASSERT.isPlainObject( this.s.grid );
        ASSERT.isNumber( this.s.grid.itemWidth );
        ASSERT.isNumber( this.s.grid.itemHeight );
        ASSERT.isNumberOrNil( this.s.grid.linesWidth );

        this._d3SetupGrid();
      }

      TB.applyCssRules( 'tb-lg-global-css', this._prepareGlobalCSS() );
      TB.applyCssRules( 'tb-lg-styles', this._stringifyCssRules() );

      this.emit( 'tb.lg.init', {
        instance: this,
      } );

      if ( data ) {
        this.updateItems( data );

        if ( this.g.isEnabled && this.s.grid.autoscale ) {

          if ( !this.s.grid.autoscaleUnpositionedOnly ) {
            this._gAutoscale();
          } else if ( this.g.hadUnpositionedElements ) {
            this._gAutoscale();
          }
        }

        if ( this.g.isEnabled && this.s.grid.autosize ) {
          this._gAutosize();
        }
      }
    }

    /** @lends TB.Livegrid.prototype */
    Livegrid.prototype = {
      version: '1.0.0',
      migrations: [
        function(data) {
          var resultData = {
            version: this.version,
            items: [],
          };

          if(data.items) {
            for(var i = 0, l = data.items.length; i < l; i++) {
              var obj = _.defaults({}, data.items[i]);

              if(obj.x && this.g.itemWidth) {
                obj.x *= this.g.itemWidth;
              }

              if(obj.y && this.g.itemHeight) {
                obj.y *= this.g.itemHeight;
              }

              resultData.items.push(obj);
            }
          }

          return resultData;
        },
      ],
      templates: {
        CSSJSON: {
          '.tb-lg-element': {
            'position': 'relative',
            'overflow': 'hidden'
          },
          '.tb-lg-element *': {
            'box-sizing': 'border-box',
            'padding': '0px',
            'margin': '0px'
          },
          '.tb-lg-element.tb-lg-panning': {
            'cursor': 'move'
          },
          '.tb-lg-resize': {
            'height': '100%',
            'position': 'relative',
            'overflow': 'visible'
          },
          '.tb-lg-wrapper': {
            'position': 'relative',
            'transform-origin': '0px 0px'
          },
          '.tb-lg-background': {
            'position': 'absolute',
            'top': 0,
            'left': 0,
            'z-index': 0
          },
          '.tb-lg-wrapper-container': {
            'height': '100%',
            'overflow': 'hidden'
          },
          '.tb-lg-element .tb-lg-navbar': {
            'height': '3.5rem',
            'display': 'initial'
          },
          '.tb-lg-navbar': {
            'position': 'absolute',
            'display': 'none',
            'left': '0px',
            'height': '0px',
            'top': '-2.5rem',
            'padding-bottom': '1rem 1rem',
            'background': 'rgba(0, 0, 0, 0.2)',
            'transition': '250ms all',
            'color': 'white',
            'font-family': 'sans-serif'
          },
          '.tb-lg-navbar:hover,\n        .tb-lg-navbar.tb-lg-active': {
            'height': '2.5rem',
            'padding': '0px',
            'top': '0px',
            'background': 'rgba(0, 0, 0, 0.8)',
            'transition': '250ms all'
          },
          '.tb-lg-navbar input[type=\'range\']': {
            'height': '5rem',
            'width': '1rem',
            'writing-mode': 'bt-lr',
            '/* IE */\n            -webkit-appearance': 'slider-vertical'
          },
          '.tb-lg-navbar .tb-lg-btn': {
            'height': '2.1rem'
          },
          '.tb-lg-navbar .tb-lg-btn[name=\'save\']:disabled': {
            'max-width': '0px',
            'padding': '0px',
            'border': 'none',
            'margin': '0px'
          },
          '.tb-lg-navbar .tb-lg-btn[name=\'save\']': {
            'max-width': '100px'
          },
          '.tb-lg-navbar:hover .tb-lg-subnavbar:hover .tb-lg-content': {
            'top': '2.5rem'
          },
          '.tb-lg-navbar:hover .tb-lg-subnavbar .tb-lg-content': {
            'top': '2.5rem'
          },
          '.tb-lg-navbar .tb-lg-subnavbar .tb-lg-content': {
            'top': '3.5rem'
          },
          '.tb-lg-subnavbar': {
            'display': 'inline-block',
            'position': 'relative'
          },
          '.tb-lg-subnavbar .tb-lg-content': {
            'height': '0px',
            'min-width': '100%',
            'overflow': 'hidden',
            'position': 'absolute',
            'transition': '250ms all',
            'background': 'rgba(0, 0, 0, 0.2)'
          },
          '.tb-lg-subnavbar:hover .tb-lg-content': {
            'height': '12rem',
            'background': 'rgba(0, 0, 0, 0.8)'
          },
          '.tb-lg-navbar table': {
            'text-align': 'center',
            'width': '100%',
            'vertical-align': 'middle'
          },
          '.tb-lg-navbar td': {
            'height': '1rem'
          },
          '.tb-lg-btn': {
            'display': 'inline-block',
            'font-size': '1rem',
            'font-weight': 'normal',
            'line-height': '1.9rem',
            'text-align': 'center',
            'white-space': 'nowrap',
            'vertical-align': 'middle',
            'touch-action': 'manipulation',
            'cursor': 'pointer',
            'user-select': 'none',
            'background-image': 'none',
            'background': 'rgba(255, 255, 255, 1)',
            'border': '1px outset rgba(180, 180, 180, 1)',
            'color': 'black',
            'padding': '1px 6px',
            'margin': '0rem 0.2rem'
          },
          '.tb-lg-btn:active, .tb-lg-btn.tb-lg-active': {
            'background': 'rgba(200, 200, 200, 1)',
            'border-style': 'inset'
          },
          '.tb-lg-items-container': {
            'position': 'relative'
          },
          '.tb-lg-item': {
            'display': 'inline-block',
            'overflow': 'auto'
          },
          '.tb-lg-element:not(.tb-lg-editing) .tb-lg-item .tb-lg-navbar': {
            'height': '0px'
          },
          '.tb-lg-element.tb-lg-editing .tb-lg-item .tb-lg-navbar': {
            'height': '0px'
          },
          '.tb-lg-element.tb-lg-griddable .tb-lg-item': {
            'position': 'absolute'
          },
          '.tb-lg-element.tb-lg-griddable .tb-lg-items-container': {
            'width': '100%',
            'height': '100%'
          },
          '.tb-lg-element.tb-lg-griddable .tb-lg-item .tb-lg-item-content': {
            'width': '100%',
            'height': '100%'
          },
          'svg.tb-lg-grid': {
            'position': 'absolute',
            'top': '0px',
            'left': '0px',
            'overflow': 'visible',
            'display': 'none'
          },
          'svg.tb-lg-grid line': {
            'stroke': 'rgb(6,120,155)',
            'stroke-width': '2px'
          },
          '.tb-lg-editing svg.tb-lg-grid': {
            'display': 'block'
          }
        },
        elContent: ' \
          <div class="tb-lg-resize"> \
            <div class="tb-lg-wrapper-container"> \
              <div class="tb-lg-wrapper"> \
                <div class="tb-lg-items-container"></div> \
              </div> \
            </div>\
            <div class="tb-lg-navbar"> \
              <button class="tb-lg-btn" name="edit" data-role="none" hidden="hidden">Edit</button> \
              <button class="tb-lg-btn" name="save" data-role="none" disabled="disabled">Save</button> \
              <button class="tb-lg-btn" name="snap" data-role="none" disabled="disabled">Toggle snap</button> \
              <!-- <div class="tb-lg-subnavbar tb-lg-subnavbar-resize tb-lg-subnavbar-resize-both"> \
                <button type="button" class="tb-lg-btn" data-role="none">Resize</button> \
                <div class="tb-lg-content"> \
                  <table> \
                    <tr> \
                      <td data-name="w-value"></td> \
                      <td data-name="h-value"></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="w-plus" data-role="none">+</button></td> \
                      <td><button type="button" class="tb-lg-btn" name="h-plus" data-role="none">+</button></td> \
                    </tr> \
                    <tr> \
                      <td><input type="range" name="w-slider" data-role="none" orient="vertical" /></td> \
                      <td><input type="range" name="h-slider" data-role="none" orient="vertical" /></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="w-minus" data-role="none">-</button></td> \
                      <td><button type="button" class="tb-lg-btn" name="h-minus" data-role="none">-</button></td> \
                    </tr> \
                  </table> \
                </div> \
              </div> --> \
              <div class="tb-lg-subnavbar tb-lg-subnavbar-opacity"> \
                <button type="button" class="tb-lg-btn" data-role="none">O</button> \
                <div class="tb-lg-content"> \
                  <table> \
                    <tr> \
                      <td data-name="opacity-value"></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="opacity-plus" data-role="none">+</button></td> \
                    </tr> \
                    <tr> \
                      <td><input type="range" name="opacity-slider" data-role="none" orient="vertical" /></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="opacity-minus" data-role="none">-</button></td> \
                    </tr> \
                  </table> \
                </div> \
              </div> \
              <div class="tb-lg-subnavbar tb-lg-subnavbar-resize tb-lg-subnavbar-resize-w"> \
                <button type="button" class="tb-lg-btn" data-role="none">&#8596;</button> \
                <div class="tb-lg-content"> \
                  <table> \
                    <tr> \
                      <td data-name="w-value"></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="w-plus" data-role="none">+</button></td> \
                    </tr> \
                    <tr> \
                      <td><input type="range" name="w-slider" data-role="none" orient="vertical" /></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="w-minus" data-role="none">-</button></td> \
                    </tr> \
                  </table> \
                </div> \
              </div> \
              <div class="tb-lg-subnavbar tb-lg-subnavbar-resize tb-lg-subnavbar-resize-h"> \
                <button type="button" class="tb-lg-btn" data-role="none">&#8597;</button> \
                <div class="tb-lg-content"> \
                  <table> \
                    <tr> \
                      <td data-name="h-value"></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="h-plus" data-role="none">+</button></td> \
                    </tr> \
                    <tr> \
                      <td><input type="range" name="h-slider" data-role="none" orient="vertical" /></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="h-minus" data-role="none">-</button></td> \
                    </tr> \
                  </table> \
                </div> \
              </div> \
              <div class="tb-lg-subnavbar tb-lg-subnavbar-zoom"> \
                <span class="tb-lg-btnset"> \
                  <button type="button" class="tb-lg-btn" data-role="none">Zoom</button> \
                  <!-- <button type="button" class="tb-lg-btn" name="zoom-in" data-role="none">+</button> --> \
                  <!-- <button type="button" class="tb-lg-btn" name="zoom-out" data-role="none">-</button> --> \
                </span> \
                <div class="tb-lg-content"> \
                  <table> \
                    <tr> \
                      <td data-name="zoom-value">x1</td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="zoom-in" data-role="none">+</button></td> \
                    </tr> \
                    <tr> \
                      <td><input type="range" name="scale-slider" data-role="none" orient="vertical" /></td> \
                    </tr> \
                    <tr> \
                      <td><button type="button" class="tb-lg-btn" name="zoom-out" data-role="none">-</button></td> \
                    </tr> \
                  </table> \
                </div> \
              </div> \
            </div>\
          </div>\
          ',
      },
      /**
       * Init function
       * @memberof Livegrid
       * @private
       * @instance
       */
      _init: function() {
        this._parseSettingsTypes();
        this._d3init();
      },
      /**
       * Migrate data if needed
       * @memberof Livegrid
       * @private
       * @instance
       * @return {*} migrated data
       */
      _migrateData: function(data) {
        for(var i = 0, l = this.migrations.length; i < l; i++) {
          var migrateFunc = this.migrations[i];

          data = migrateFunc.call(this, data);
        }

        return data;
      },
      /**
       * Parse settings types
       * @memberof Livegrid
       * @private
       * @instance
       */
      _parseSettingsTypes: function() {
        var types = this.s['types'];

        this.css[0] = this.css[0] || [];

        // Parse type, attribute, state and class definitions
        for ( var typeName in types ) {
          var rawTypeSettings = types[ typeName ];

          ASSERT.isString( typeName );
          ASSERT.isString( rawTypeSettings.template );
          ASSERT.isPlainObject( rawTypeSettings.attributes );
          ASSERT.isPlainObject( rawTypeSettings.contents );
          ASSERT.isPlainObjectOrNil( rawTypeSettings.cssjson );

          var typeSettings = {
            name: typeName,
            template: rawTypeSettings.template,
            contentScaleSelector: rawTypeSettings.contentScaleSelector,
            attributesNameList: Object.keys( rawTypeSettings.attributes ),
            contentsNameList: Object.keys( rawTypeSettings.contents ),
            className: this.prefixClassName( typeName ),
            attributes: {},
            contents: {},
          };


          if ( rawTypeSettings.cssjson ) {
            this._parseCSSJSON( typeSettings.className, 0, rawTypeSettings.cssjson );
          }


          this.types[ typeName ] = typeSettings;


          for ( var contentName in rawTypeSettings.contents ) {
            ASSERT.isString( contentName );
            ASSERT.isPlainObjectOrNil( rawTypeSettings.contents[ contentName ] );
            ASSERT.isString( rawTypeSettings.contents[ contentName ].selector );
            ASSERT.isStringOrNil( rawTypeSettings.contents[ contentName ].property );
            ASSERT.isStringOrNil( rawTypeSettings.contents[ contentName ].attribute );
            ASSERT( _.isNil( rawTypeSettings.contents[ contentName ].property ) || _.isNil( rawTypeSettings.contents[ contentName ].attribute ) );


            var rawContentSettings = rawTypeSettings.contents[ contentName ];
            var contentSettings = {
              selector: rawContentSettings.selector,
              property: null,
              propertyArr: null,
              attribute: null,
            };


            if ( rawContentSettings.attribute ) {
              contentSettings.attribute = rawContentSettings.attribute;
            } else {
              contentSettings.property = rawContentSettings.property || 'textContent';
              contentSettings.propertyArr = contentSettings.property.split( '.' );
            }

            this.types[ typeName ].contents[contentName] = contentSettings;
          }


          for ( var attributeName in rawTypeSettings.attributes ) {
            ASSERT.isString( attributeName );
            ASSERT.isPlainObject( rawTypeSettings.attributes[ attributeName ] );
            ASSERT.isPlainObject( rawTypeSettings.attributes[ attributeName ].states );
            ASSERT.isNumber( rawTypeSettings.attributes[ attributeName ].priority );
            ASSERT( rawTypeSettings.attributes[ attributeName ].priority > 0 );


            var rawAttributeSettings = rawTypeSettings.attributes[ attributeName ];
            var attributeSettings = {
              name: attributeName,
              priority: parseInt( rawAttributeSettings.priority ),
              stateList: Object.keys( rawAttributeSettings.states ),
              stateClassNames: {},
            };


            typeSettings.attributes[attributeName] = attributeSettings;
            this.css[rawAttributeSettings.priority] = this.css[rawAttributeSettings.priority] || [];


            for ( var stateName in rawAttributeSettings.states ) {
              ASSERT.isString( stateName );
              ASSERT.isPlainObject( rawAttributeSettings.states[ stateName ] );
              ASSERT.isPlainObject( rawAttributeSettings.states[ stateName ].cssjson);


              var rawStateSettings = rawAttributeSettings.states[ stateName ];
              var stateClassName = this.prefixClassName( [typeName, attributeName, stateName].join( '-' ) );


              attributeSettings.stateClassNames[ stateName ] = stateClassName;


              this._parseCSSJSON( stateClassName, rawAttributeSettings.priority, rawStateSettings.cssjson );
            }
          }
        }
      },
      /**
       * Converts JSON object to css and add it to this.css
       * @memberof Livegrid
       * @param {Object} cssjson JSON containing css // e.g. {".selector span": { borderColor: "red", "line-height": "2em"}}
       * @todo Support cssSelector containing comma // e.g. "p .something, div .something"
       */
      _parseCSSJSON: function( CSSnamespace, priority, cssjson ) {
        for ( var cssSelector in cssjson ) {
          ASSERT.isString( cssSelector );
          ASSERT.isPlainObject( cssjson[cssSelector] );


          // Add empty space when not matching states ( :focus, :active, :hover, etc )
          var emptySpace = ( /^:/ ).test( cssSelector ) ? '' : ' ';
          var fullSelector = ['.' + CSSnamespace, emptySpace, cssSelector].join( '' );

          this.css[ priority ].push( {
            selector: fullSelector,
            originalSelector: cssSelector,
            cssjson: cssjson[ cssSelector ],
          } );
        }
      },
      /**
       * Set prefix to generated class names to prevent collision
       * @param  {String} className class name to prefix
       * @return {String}           Prefixed class name
       */
      prefixClassName: function( className ) {
        return ( ( TB.isString( this.s.prefixClassName ) ) ? this.s.prefixClassName : '' ) + className;
      },
      /**
       * Update element's coordinates with new value or use old ones
       * @param  {Object} rawObj raw update object data
       * @param  {Object} obj    object to get updated
       */
      _gUpdateItemCoordinates: function( rawObj, obj ) {
        ASSERT.isEqual( _.isNil( rawObj.x ), _.isNil( rawObj.y ), { msg: 'Both x and y must be either defined or undefined', } );

        if ( TB.isDefined( rawObj.x ) ) {
          var swapObj = this._gGetItemAtIndex( rawObj.x, rawObj.y, this.g.indexTable );

          if ( swapObj === obj ) {
            return;
          }

          ASSERT( _.isNil( swapObj ) || (swapObj && swapObj.lastUpdateChecksum !== obj.lastUpdateChecksum), { msg: 'Two elements have the same coordinates', } );

          this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTable );
          this._gSetItemAtIndex( rawObj.x, rawObj.y, obj, this.g.indexTable );
          this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTableAll );
          this._gSetItemAtIndex( rawObj.x, rawObj.y, obj, this.g.indexTableAll );

          obj.xCalc = rawObj.x;
          obj.yCalc = rawObj.y;
          obj.x = rawObj.x;
          obj.y = rawObj.y;

          this._gUpdateMinMaxPositionedXY( obj.x, obj.y );

        } else if ( TB.isEmpty( obj.x ) ) {
          this.g.unpositionedElements.push( obj );
        } else {
          // TODO why this is empty?
        }
      },
      /**
       * Updates temporary coordinates for unpositioned items (items without X and Y
       * coordinates )
       */
      _gUpdateUnpositionedItemsCoordinates: function() {
        this.g.hadUnpositionedElements = (this.g.unpositionedElements.length > 0);

        if ( this.g.unpositionedElements.length === 0 ) {
          return;
        }

        var indexOfUnpositionedRow = ( this.g.unpositionedElements.length !== this.objList.length )
          ? ((this.g.maxPositionedY + this.s.grid.unpositionedItemsBuffer * this.g.itemHeight) / this.g.itemHeight)
          : 0;

        outerLoop: for ( var i = indexOfUnpositionedRow; true; i++ ) {
          innerLoop: for ( var j = 0; j < this.s.grid.unpositionedItemsPerRow; j++ ) {
            var el = this._gGetItemAtIndex( j, i, this.g.indexTable );

            if ( !_.isNil( el ) ) {
              continue innerLoop;
            }

            var unpositionedItem = this.g.unpositionedElements.shift();

            if ( _.isNil( unpositionedItem ) ) {
              break outerLoop;
            }

            var xCoord = j * this.g.itemWidth;
            var yCoord = i * this.g.itemHeight;

            unpositionedItem.xCalc = xCoord;
            unpositionedItem.yCalc = yCoord;

            this._gRemoveItemAtIndex( xCoord, yCoord, this.g.indexTableAll );
            this._gSetItemAtIndex( xCoord, yCoord, unpositionedItem, this.g.indexTableAll );
            this._gUpdateMinMaxPositionedXY( xCoord, yCoord );
          }
        }

        ASSERT.isEmpty( this.g.unpositionedElements );
      },
      /**
       * Event handler when zoom slider gets input
       */
      _handlerOnInputSliderZoom: function() {
        this.g.zoom.scale( TB.limitToRange( this.DOMsliderZoom[0][0].value, this.s.grid.minZoom, this.s.grid.maxZoom ) );
        this._gZoomCallback();
      },
      /**
       * Event handler zoom buttons clicked
       * @private
       */
      _handlerOnChangeSliderZoom: function() {
        this.g.zoom.scale( TB.limitToRange( this.DOMsliderZoom[0][0].value, this.s.grid.minZoom, this.s.grid.maxZoom ) );
        this._gZoomCallback();
      },
      /**
       * Event handler when zoom buttons are clicked
       * @private
       */
      _handlerOnClickBtnZoom: function() {
        switch ( d3.event.target.name ) {
        case 'zoom-in':
          this.DOMsliderZoom[0][0].stepUp();
          break;
        case 'zoom-out':
          this.DOMsliderZoom[0][0].stepDown();
          break;
        default:
          THROW_SYS( 'Unknown button' );
        }

        this.g.zoom.scale( TB.limitToRange( this.DOMsliderZoom[0][0].value, this.s.grid.minZoom, this.s.grid.maxZoom ) );
        this._gZoomCallback();
      },
      /**
       *
       **/
      _handlerOnInputSliderOpacity: function() {
        this.g.opacity = TB.limitToRange( this.DOMsliderOpacity[0][0].value, this.s.grid.minOpacity, this.s.grid.maxOpacity );


        if( this.g.svgGrid ) {
          this.g.svgGrid.style( 'opacity', this.g.opacity );
        }

        this.DOMitemsContainer.style( 'opacity', this.g.opacity );
        this._d3UpdateOpacityValue();
      },
      /**
       *
       **/
      _handlerOnChangeSliderOpacity: function() {
        this.g.opacity = TB.limitToRange( this.DOMsliderOpacity[0][0].value, this.s.grid.minOpacity, this.s.grid.maxOpacity );

        if( this.g.svgGrid ) {
          this.g.svgGrid.style( 'opacity', this.g.opacity );
        }

        this.DOMitemsContainer.style( 'opacity', this.g.opacity );
        this._d3UpdateOpacityValue();
      },
      /**
       *
       **/
      _handlerOnClickBtnOpacity: function() {
        switch ( d3.event.target.name ) {
        case 'opacity-plus':
          this.DOMsliderOpacity[0][0].stepUp();
          break;
        case 'opacity-minus':
          this.DOMsliderOpacity[0][0].stepDown();
          break;
        default:
          THROW_SYS( 'Unknown button' );
        }

        this.g.opacity = TB.limitToRange( this.DOMsliderOpacity[0][0].value, this.s.grid.minOpacity, this.s.grid.maxOpacity );

        if( this.g.svgGrid ) {
          this.g.svgGrid.style( 'opacity', this.g.opacity );
        }

        this.DOMitemsContainer.style( 'opacity', this.g.opacity );
        this._d3UpdateOpacityValue();
      },
      /**
       * Event handler when resize slider gets input
       * @private
       */
      _handlerOnInputSliderResize: function() {
        this._gApplyResizeItems();
      },
      /**
       * Event handler when resize slider is changed
       * @private
       */
      _handlerOnChangeSliderResize: function() {
        this._gApplyResizeItems();
      },
      /**
       * Event handler when resize slider is mousewheeled
       * @private
       */
      _handlerOnMousewheelSliderResize: function() {
        d3.event.stopPropagation();
        d3.event.preventDefault();

        if ( d3.event.deltaY === 0 ) {
          return;
        } else if ( d3.event.deltaY > 0 ) {
          d3.event.target.stepUp( 5 );
        } else {
          d3.event.target.stepDown( 5 );
        }

        this._gApplyResizeItems();
      },
      /**
       * Event handler when resize items buttons are clicked
       * @private
       */
      _handlerOnClickBtnResize: function() {
        switch ( d3.event.target.name ) {
        case 'w-plus':
          this.DOMsliderWidth[0][0].stepUp();
          break;
        case 'w-minus':
          this.DOMsliderWidth[0][0].stepDown();
          break;
        case 'h-plus':
          this.DOMsliderHeight[0][0].stepUp();
          break;
        case 'h-minus':
          this.DOMsliderHeight[0][0].stepDown();
          break;
        default:
          THROW_SYS( 'Unknown button' );
        }

        this._gApplyResizeItems();
      },
      /**
       * Event handler when clear coordinates of item is clicked
       * @param  {Object} item item object
       */
      _handlerOnClickBtnClear: function( item ) {
        this._gRemoveItemAtIndex( item.x, item.y, this.g.indexTable );
        this._gRemoveItemAtIndex( item.x, item.y, this.g.indexTableAll );

        item.x = null;
        item.y = null;
      },
      /**
       * Apply resize of items in the grid
       * @private
       */
      _gApplyResizeItems: function() {
        var self = this;

        this.g.oldItemWidth = this.g.itemWidth;
        this.g.oldItemHeight = this.g.itemHeight;

        this.g.itemHeight = TB.limitToRange( this.DOMsliderHeight[0][0].value, this.s.grid.minItemHeight, this.s.grid.maxItemHeight );
        this.g.itemWidth = TB.limitToRange( this.DOMsliderWidth[0][0].value, this.s.grid.minItemWidth, this.s.grid.maxItemWidth );

        var xDiff = this.g.itemWidth - this.g.oldItemWidth;
        var yDiff = this.g.itemHeight - this.g.oldItemHeight;


        this.objList.forEach(function(obj) {
          var colIndex = Math.floor(obj.xCalcTemp / self.g.oldItemWidth);
          var rowIndex = Math.floor(obj.yCalcTemp / self.g.oldItemHeight);

          obj.xCalcTemp += xDiff * colIndex;
          obj.yCalcTemp += yDiff * rowIndex;
        });

        this._d3UpdateResizeValues();
        this._d3UpdateWrapper();
        this._d3UpdateBackgroundGrid();
        this._d3UpdateItems();
      },
      /**
       * Update grid's min and max positioned element coordinates
       * @private
       * @param  {Number} x check value for X axis
       * @param  {Number} y check value for Y axis
       */
      _gUpdateMinMaxPositionedXY: function( x, y ) {
        this.g.minPositionedX = ( x < this.g.minPositionedX || this.g.minPositionedX === null ) ? x : this.g.minPositionedX;
        this.g.minPositionedY = ( y < this.g.minPositionedY || this.g.minPositionedY === null ) ? y : this.g.minPositionedY;
        this.g.maxPositionedX = ( x > this.g.maxPositionedX || this.g.maxPositionedX === null ) ? x : this.g.maxPositionedX;
        this.g.maxPositionedY = ( y > this.g.maxPositionedY || this.g.maxPositionedY === null ) ? y : this.g.maxPositionedY;

        this.g.rowsCount = this.g.maxPositionedY + this.s.grid.itemsBuffer;
        this.g.colsCount = this.g.maxPositionedX + this.s.grid.itemsBuffer;
      },
      /**
       * Update grid's min and max positioned element coordinates to 0
       * @private
       */
      _gResetMinMaxPositionedXY: function( ) {
        this.g.minPositionedX = 0;
        this.g.minPositionedY = 0;
        this.g.maxPositionedX = 0;
        this.g.maxPositionedY = 0;

        this.g.rowsCount = this.s.grid.itemsBuffer;
        this.g.colsCount = this.s.grid.itemsBuffer;
      },
      /**
       * Autoscale container elements. Set's zoom level to value which allowes
       * displaying all elements in current container element size
       * @private
       */
      _gAutoscale: function() {
        var positionedElementsWidth = ( Math.floor( this.g.maxPositionedX / this.g.itemWidth ) - Math.floor( this.g.minPositionedX / this.g.itemWidth ) + 1 ) * this.g.itemWidth;
        var positionedElementsHeight = ( Math.floor( this.g.maxPositionedY / this.g.itemHeight ) - Math.floor( this.g.minPositionedY / this.g.itemHeight) + 1 ) * this.g.itemHeight;
        var scale = Math.min( this.elWidth / positionedElementsWidth, this.elHeight / positionedElementsHeight );

        this.g.translateX = this.g.minPositionedX * this.g.itemWidth;
        this.g.translateY = this.g.minPositionedY * this.g.itemHeight;

        this.g.zoom.scale( TB.limitToRange( scale, this.s.grid.minZoom, this.s.grid.maxZoom ) );
        this._gZoomCallback();
      },
      /**
       * Autosize containers element size (width and height). grid will be shown
       * with zoom level 1, even when screen size is not enough, so in most
       * cases it'll produce scrollbars to the window (or overflowed parent)
       * @deprecated Experimental feature, please do not use
       */
      _gAutosize: function() {
        var positionedElementsWidth = ( this.g.maxPositionedX - this.g.minPositionedX + 1 ) * this.g.itemWidth;
        var positionedElementsHeight = ( this.g.maxPositionedY - this.g.minPositionedY + 1 ) * this.g.itemHeight;

        this.g.translateX = this.g.minPositionedX * this.g.itemWidth;
        this.g.translateY = this.g.minPositionedY * this.g.itemHeight;

        this.g.zoom.scale( 1 );
        this._gUpdateElementSize( positionedElementsWidth, positionedElementsHeight );
        this._gZoomCallback();
      },
      /**
       * Updates container element size (width and height) with passed parameters
       * @private
       * @param {Number} width width in pixels
       * @param {Number} height height in pixels
       */
      _gUpdateElementSize: function( width, height ) {
        ASSERT( width > 0 );
        ASSERT( height > 0 );

        this.DOMel.style( 'width', TB.toPx( width ) );
        this.DOMel.style( 'height', TB.toPx( height ) );
      },
      /**
       * Set timeout to expire object
       * @param  {Object} obj [description]
       */
      _timeoutExpireObject: function( obj ) {
        obj.timeouts.expires = setTimeout( function() {
          var index = this.objList.indexOf( obj );

          if ( index < 0 ) {
            return;
          }

          delete this.objHash[ obj.id ];
          delete this._timeouts[ obj.expiresIn ][ obj.timeouts.expires ];

          this.objList.splice( index, 1 );

          this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTable );
          this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTableAll );

          if ( this.g.indexTableTemp ) {
            this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTableTemp );
          }


          if ( Object.keys( this._timeouts[ obj.expiresIn ] ).length === 0 ) {
            this._d3UpdateItems();
          }
        }.bind( this ), obj.expiresIn * 1000 );

        this._timeouts[ obj.expiresIn ] = this._timeouts[ obj.expiresIn ] || {};
        this._timeouts[ obj.expiresIn ][ obj.timeouts.expires ] = true;
      },
      /**
       * Init DOM elements
       * @memberof Livegrid
       * @private
       * @instance
       */
      _d3init: function() {
        var self = this;
        var element = this.s.element;

        ASSERT( element instanceof HTMLElement || _.isString( element ), { msg: 'Element must be an HTMLElement or string', } );

        this.DOMel = d3.select( element )
          .classed( 'tb-lg-element', true )
          .html( this.templates.elContent );

        ASSERT( this.DOMel.length > 0 && this.DOMel[0] !== null, { msg: 'Element was not found for "%s"', } );

        this.DOMwrapper = this.DOMel.select( '.tb-lg-wrapper' );
        this.DOMitemsContainer = this.DOMwrapper.select( '.tb-lg-items-container' );
        this.DOMnavbar = this.DOMel.select( '.tb-lg-navbar' );

        this.elHeight = parseInt( this.DOMel.style( 'height' ), 10 );
        this.elWidth = parseInt( this.DOMel.style( 'width' ), 10 );


        if( this.s.backgroundImage && this.s.backgroundImage.src ) {
          var img = new Image();

          img.onload = function () {
            this.DOMwrapper.insert( 'img', ':first-child' )
              .classed( 'tb-lg-background', true )
              .attr( 'src', this.s.backgroundImage.src )
              .attr( 'width', this.s.backgroundImage.width || 'auto' )
              .attr( 'height', this.s.backgroundImage.height || 'auto' );
          }.bind(this);

          img.src = this.s.backgroundImage.src;
        }

        if ( !this.g.isEnabled || this.s.hideInactiveMenu || this.disableMenu ) {
          this.DOMnavbar.style( 'display', 'none' );
          // return;
        }

        var subnavbarZoom = this.DOMnavbar.select( '.tb-lg-subnavbar-zoom' ).style( 'display', 'none' );
        var subnavbarResizeBoth = this.DOMnavbar.select( '.tb-lg-subnavbar-resize-both' ).style( 'display', 'none' );
        var subnavbarResizeH = this.DOMnavbar.select( '.tb-lg-subnavbar-resize-h' ).style( 'display', 'none' );
        var subnavbarResizeW = this.DOMnavbar.select( '.tb-lg-subnavbar-resize-w' ).style( 'display', 'none' );
        var subnavbarOpacity = this.DOMnavbar.select( '.tb-lg-subnavbar-opacity' ).style( 'display', 'none' );

        this.DOMbtnEdit = this.DOMnavbar.select( '.tb-lg-btn[name="edit"]' );
        this.DOMbtnSave = this.DOMnavbar.select( '.tb-lg-btn[name="save"]' );
        this.DOMbtnSnap = this.DOMnavbar.select( '.tb-lg-btn[name="snap"]' );


        this.DOMnavbar.selectAll( '.tb-lg-subnavbar-zoom .tb-lg-content .tb-lg-btn' )
          .on( 'click', this._handlerOnClickBtnZoom.bind( this ) );


        this.DOMsliderZoom = this.DOMnavbar.select( '.tb-lg-subnavbar-zoom input[name="scale-slider"]' )
          .property( 'min', this.s.grid.minZoom )
          .property( 'max', this.s.grid.maxZoom )
          .property( 'step', this.s.grid.stepZoom )
          .property( 'value', Math.min( 1, this.s.grid.maxZoom ) )
          .on( 'input', this._handlerOnInputSliderZoom.bind( this ) )
          .on( 'change', this._handlerOnChangeSliderZoom.bind( this ) );


        this.DOMnavbar.selectAll( '.tb-lg-subnavbar-resize .tb-lg-content .tb-lg-btn' )
          .on( 'click', this._handlerOnClickBtnResize.bind( this ) );


        if ( this.s.menuElement ) {
          this.DOMmenuEl = d3.select( this.s.menuElement );
          this.DOMmenuEl[0][0].appendChild( this.DOMnavbar[0][0] );
        }


        this.DOMsliderZoomValue = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-zoom .tb-lg-content [data-name="zoom-value"]' );
        this.DOMsliderOpacityValue = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-opacity .tb-lg-content [data-name="opacity-value"]' );
        this.DOMsliderOpacityValue.text( (+this.g.opacity).toFixed(2) );

        this.DOMsliderHeightValue = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-resize .tb-lg-content [data-name="h-value"]' )
          .text( this.g.itemHeight );

        this.DOMsliderHeight = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-resize .tb-lg-content input[name="h-slider"]' )
          .property( 'min', this.s.grid.minItemHeight )
          .property( 'max', this.s.grid.maxItemHeight )
          .property( 'value', this.g.itemHeight )
          .on( 'input', this._handlerOnInputSliderResize.bind( this ) )
          .on( 'change', this._handlerOnChangeSliderResize.bind( this ) )
          .on( 'mousewheel', this._handlerOnMousewheelSliderResize.bind( this ) );

        this.DOMsliderWidthValue = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-resize .tb-lg-content [data-name="w-value"]' )
          .text( this.g.itemWidth );

        this.DOMsliderWidth = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-resize .tb-lg-content input[name="w-slider"]' )
          .property( 'min', this.s.grid.minItemWidth )
          .property( 'max', this.s.grid.maxItemWidth )
          .property( 'value', this.g.itemWidth )
          .on( 'input', this._handlerOnInputSliderResize.bind( this ) )
          .on( 'change', this._handlerOnChangeSliderResize.bind( this ) )
          .on( 'mousewheel', this._handlerOnMousewheelSliderResize.bind( this ) );

        this.DOMnavbar.selectAll( '.tb-lg-subnavbar-opacity .tb-lg-content .tb-lg-btn' )
          .on( 'click', this._handlerOnClickBtnOpacity.bind( this ) );

        this.DOMsliderOpacity = this.DOMnavbar.selectAll( '.tb-lg-subnavbar-opacity .tb-lg-content input[name="opacity-slider"]' )
          .property( 'min', this.s.grid.minOpacity )
          .property( 'max', this.s.grid.maxOpacity )
          .property( 'step', this.s.grid.stepOpacity )
          .property( 'value', this.g.opacity )
          .on( 'input', this._handlerOnInputSliderOpacity.bind( this ) )
          .on( 'change', this._handlerOnChangeSliderOpacity.bind( this ) );

        this.DOMitemsContainer.style( 'opacity', this.g.opacity );

        if ( this.g.isEnabled ) {
          this.DOMbtnEdit
            .on( 'click', this.toggleEditMode.bind(this) )
            .style( 'display', 'none' );

          this.DOMbtnSave
            .classed( 'tb-lg-btn', true )
            .attr( 'disabled', true )
            .style( 'display', 'none' )
            .text( 'Save' )
            .on( 'click', this.save.bind( this ) );

          this.DOMbtnSnap
            .classed( 'tb-lg-btn', true )
            .attr( 'disabled', true )
            .on( 'click', this.toggleSnapMode.bind(this) )
        }

        var menuItemsMap = {
          edit: this.DOMbtnEdit,
          save: this.DOMbtnSave,
          snap: this.DOMbtnSnap,
          zoom: subnavbarZoom,
          opacity: subnavbarOpacity,
          // resizeBoth: subnavbarResizeBoth, /** @todo implement */
          resizeH: subnavbarResizeH,
          resizeW: subnavbarResizeW,
        };

        for ( var i = 0, l = this.s.menuItems.length; i < l; i++ ) {
          var menuItem = this.s.menuItems[ i ];
          var DOMmenuItemElement = menuItemsMap[ menuItem ];

          if ( DOMmenuItemElement ) {
            DOMmenuItemElement.style( 'display', 'inline-block' );

            this.DOMnavbar[0][0]
              .appendChild( DOMmenuItemElement[0][0] );
          }
        }
      },
      /**
       * Update content of item's resize values shown in the upper navbar
       * @private
       */
      _d3UpdateResizeValues: function() {
        this.DOMsliderWidthValue.text( this.g.itemWidth );
        this.DOMsliderHeightValue.text( this.g.itemHeight );
      },
      /**
       * Update content of item's zoom value shown in the upper navbar
       * @private
       */
      _d3UpdateZoomValue: function() {
        this.DOMsliderZoomValue.text( 'x' + this.g.zoom.scale().toFixed( 2 ) );
      },
      /**
       * Update content of item's opacity value shown in the upper navbar
       * @private
       */
      _d3UpdateOpacityValue: function() {
        this.DOMsliderOpacityValue.text( (+this.g.opacity).toFixed( 2 ) );
      },
      /**
       * Redraw background grid
       * @private
       */
      _d3UpdateBackgroundGrid: function() {
        var zoomedWrapperWidth = this.g.wrapperActiveWidth;
        var zoomedWrapperHeight = this.g.wrapperActiveHeight;
        var xaxiscoorddata = d3.range( 0, zoomedWrapperWidth, this.g.itemWidth );
        var yaxiscoorddata = d3.range( 0, zoomedWrapperHeight, this.g.itemHeight );
        var verticalLines = this.g.svgGrid.selectAll( 'line.vertical' )
          .data( xaxiscoorddata );
        var horizontalLines = this.g.svgGrid.selectAll( 'line.horizontal' )
          .data( yaxiscoorddata );

        verticalLines.exit().remove();
        verticalLines.enter().append( 'svg:line' )
          .classed( 'vertical', true )
          .attr( 'y1', 0 );
        verticalLines
          .attr( 'x1', this._returnDatum() )
          .attr( 'x2', this._returnDatum() )
          .attr( 'y2', zoomedWrapperHeight );


        horizontalLines.exit().remove();
        horizontalLines.enter().append( 'svg:line' )
          .classed( 'horizontal', true )
          .attr( 'x1', 0 );
        horizontalLines
          .attr( 'y1', this._returnDatum() )
          .attr( 'y2', this._returnDatum() )
          .attr( 'x2', zoomedWrapperWidth );

      },
      /**
       * Make grid zoomable using d3 zoom behaviour
       * @private
       */
      _d3GridZoomable: function() {
        var self = this;

        this.g.zoom = d3.behavior.zoom()
          .scaleExtent( [this.s.grid.minZoom, this.s.grid.maxZoom] )
          .on( 'zoom', this._gZoomCallback.bind( this ) );

        this.g.zoomDrag = d3.behavior.drag()
          .on( 'dragstart', function() {
            if ( self.s.grid.disablePanningInNormalMode && !self.g.editMode ) {
              return;
            }

            d3.event.sourceEvent.stopPropagation();
            self.DOMel.classed( 'tb-lg-panning', true );
          } )
          .on( 'drag', function() {
            if ( self.s.grid.disablePanningInNormalMode && !self.g.editMode ) {
              return;
            }

            var scale = self.g.zoom.scale();
            var values = '';

            self.g.translateX = TB.limitToRange( self.g.translateX + d3.event.dx, -Math.max( 0, self.g.wrapperActiveWidth * scale - self.elWidth ), 0 );
            self.g.translateY = TB.limitToRange( self.g.translateY + d3.event.dy, -Math.max( 0, self.g.wrapperActiveHeight * scale - self.elHeight ), 0 );

            values = [self.g.translateX, self.g.translateY].map( function( x ) { return TB.toPx( x ); } ).join( ',' );

            self.DOMwrapper.style( 'transform', 'translate( ' + values + ') scale( ' + scale + ')' );
          } )
          .on( 'dragend', function() {
            if ( self.s.grid.disablePanningInNormalMode && !self.g.editMode ) {
              return;
            }

            self.DOMel.classed( 'tb-lg-panning', false );
          } );


        this.DOMwrapper
          .on( 'mousedown.zoom', null );

        this.DOMwrapper
          .call( this.g.zoom )
          .on( 'mousedown.zoom', null )
          .on( 'touchstart.zoom', null )
          .on( 'touchmove.zoom', null )
          .on( 'touchmove.zoom', null )
          .on( 'dblclick.zoom', null )
          .call( this.g.zoomDrag );

        if ( this.s.grid.disableWheelZoom ) {
          this.DOMwrapper
            .on( 'wheel.zoom', null );
        }
      },
      /**
       * Maked grid's items draggable (changing their position)
       * @private
       * @todo support swapping two objects
       * @todo support draging items out of current visible grid
       */
      _d3GridItemsDraggable: function() {
        var self = this;

        var dragStart = {
          x: 0,
          y: 0
        };

        this.g.D3dragItems = d3.behavior.drag()
          .on( 'dragstart', function() {
            d3.event.sourceEvent.stopPropagation();
            self.DOMel.classed( 'tb-lg-dragging', true );
            d3.select( this ).classed( 'tb-lg-active', true );

            var coords = d3.mouse(this);

            dragStart.x = coords[0];
            dragStart.y = coords[1];
          } )
          .on( 'drag', function() {
            var scale = self.g.zoom.scale();
            var obj = self.objHash[ d3.select( this ).data()[0].id ];

            // TODO –∫–æ–≥–∞—Ç–æ –µ –∑–∞–≤—ä—Ä—Ç—è–Ω –µ–ª–µ–º–µ–Ω—Ç–∞, —Å–µ –ø–æ–ª—É—á–∞–≤–∞ –ª–µ–∫–æ –∏–∑–º–µ—Å—Ç–≤–∞–Ω–µ, —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –æ—Ç—á–∏—Ç–∞ –∑–∞–≤—ä—Ä—Ç–∞–Ω–µ—Ç–æ —Å—ä—â–æ!
            var tempX = d3.event.x - dragStart.x;
            var tempY = d3.event.y - dragStart.y;
            var newX;
            var newY;

            if(self.g.snapMode) {
              newX = TB.limitToRange( Math.floor( tempX / self.g.itemWidth / scale ), 0, self.g.colsCount ) * self.g.itemWidth;
              newY = TB.limitToRange( Math.floor( tempY / self.g.itemHeight / scale ), 0, self.g.rowsCount ) * self.g.itemHeight;
            } else {
              newX = TB.limitToRange( Math.floor( tempX / scale ), 0, self.g.colsCount * self.g.itemWidth );
              newY = TB.limitToRange( Math.floor( tempY / scale ), 0, self.g.rowsCount * self.g.itemHeight );
            }

            var swapObj = self._gGetItemAtIndex( newX, newY, self.g.indexTableTemp );

            self.isDragging = true;

            if ( !obj ) {
              return;
            }

            if ( newX === obj.xCalcTemp && newY === obj.yCalcTemp ) {
              return;
            }

            if ( TB.isDefined( swapObj ) && swapObj !== obj ) {
              return;
            }

            self._gRemoveItemAtIndex( obj.xCalcTemp, obj.yCalcTemp, self.g.indexTableTemp );
            self._gSetItemAtIndex( newX, newY, obj, self.g.indexTableTemp );

            obj.xCalcTemp = newX;
            obj.yCalcTemp = newY;

            d3.select( this )
              .style( 'left', TB.toPx( newX ) )
              .style( 'top', TB.toPx( newY ) );
          } )
          .on( 'dragend', function() {
            setTimeout(function() {
              self.isDragging = false;
            });

            d3.event.sourceEvent.stopPropagation();
            self.DOMel.classed( 'tb-lg-dragging', false );
            d3.select( this ).classed( 'tb-lg-active', false );
          } );
      },
      /**
       * Updates wrapper size (width and height) by given values or set it to best
       * size to show all content
       * @private
       * @param {?Number} width width in pixels
       * @param {?Number} height height in pixels
       */
      _d3UpdateWrapper: function( width, height ) {
        if ( TB.isEmpty( width ) ) {
          var itemsPerRowZoom = Math.ceil( ( this.elWidth / this.g.itemWidth ) / this.s.grid.minZoom );

          this.g.wrapperActiveWidth = Math.max( itemsPerRowZoom, this.g.rowsCount ) * this.g.itemWidth;
        } else {
          this.g.wrapperActiveWidth = width;
        }

        if ( TB.isEmpty( height ) ) {
          var itemsPerColZoom = Math.ceil( ( this.elHeight / this.g.itemHeight ) / this.s.grid.minZoom );

          this.g.wrapperActiveHeight = Math.max( itemsPerColZoom, this.g.colsCount ) * this.g.itemHeight;
        } else {
          this.g.wrapperActiveHeight = height;
        }

        this.DOMwrapper
          .style( 'width', TB.toPx( this.g.wrapperActiveWidth ) )
          .style( 'height', TB.toPx( this.g.wrapperActiveHeight ) );

        if ( this.elHeight === 0 && this.s.grid.autoheight ) {
          var newHeight = 2 * this.g.itemHeight;

          this.elHeight = newHeight;
          this.DOMel.style( 'height', TB.toPx( newHeight ) );
        }
      },
      /**
       * Executes when grid is enabled.
       * @private
       */
      _d3SetupGrid: function() {
        this.DOMel
          .classed( 'tb-lg-griddable', true );

        this.g.svgGrid = this.DOMwrapper.insert( 'svg', ':first-child' )
            .classed( 'tb-lg-grid', true );

        this._d3UpdateWrapper();
        this._d3UpdateBackgroundGrid();
        this._d3GridZoomable();


        if ( this.s.grid.isEditable ) {
          this._d3GridItemsDraggable();
        }
      },
      /**
       * After zoom apply new X and Y translation to wrapper
       * @private
       */
      _gZoomCallback: function() {
        var scale = this.g.zoom.scale();
        // if ( d3.event.translate ) {
        //     this.g.translateX = TB.limitToRange( -d3.event.translate[0] + this.elWidth / 2 * scale, -Math.max(0, this.g.wrapperActiveWidth * scale - this.elWidth ), 0);
        //     this.g.translateY = TB.limitToRange( -d3.event.translate[1] + this.elHeight / 2 * scale, -Math.max(0, this.g.wrapperActiveHeight * scale - this.elHeight ), 0);
        // } else {
        // }

        this.g.translateX = TB.limitToRange( this.g.translateX + this.elWidth / 2 * scale, -Math.max( 0, this.g.wrapperActiveWidth * scale - this.elWidth ), 0 );
        this.g.translateY = TB.limitToRange( this.g.translateY + this.elHeight / 2 * scale, -Math.max( 0, this.g.wrapperActiveHeight * scale - this.elHeight ), 0 );

        var translateValues = [this.g.translateX, this.g.translateY];
        var values = translateValues.map( function( x ) { return TB.toPx( -Math.abs( x ) ); } ).join( ',' );
        var transform = 'scale( ' + scale + ' ) translate( ' + values + ' )';

        this._d3UpdateZoomValue();
        this.DOMsliderZoom.property( 'value', scale );
        this.DOMwrapper
          .style( 'transform', transform );

      },
      /**
       * Prepare global css for use
       * @return {String} generated css
       */
      _prepareGlobalCSS: function () {
        var css = '';

        for ( var selector in this.s.CSSJSON ) {
          var attributes = this.s.CSSJSON[ selector ];

          css += TB.JSON2CSS( selector, attributes );
        }

        return css;
      },
      /** Convert css array to string
       * @private
       * @return {String}
       */
      _stringifyCssRules: function() {
        var cssText = '';

        this.css.forEach( function( priorityLevel ) {
          priorityLevel.forEach( function( cssRule ) {
            var resultCss = TB.JSON2CSS( cssRule.selector, cssRule.cssjson );

            cssText += resultCss;
          } );
        } );

        return cssText;
      },

      /**
       * D3 helper - return datum value by path
       * @private
       * @param  {?(String|Array)} path property path
       * @return {*}      value
       */
      _returnDatum: function( path ) {
        if ( path ) {
          return function( d ) {
            return TB.get( d, path );
          };
        } else {
          return function( d ) {
            return d;
          };
        }
      },
      /**
       * @deprecated
       */
      updateElements: function() {
        alert( '"instance.updateElements" is now deprecated, please use "instance.updateItems"' );
        this.updateItems.apply( this, arguments );
      },
      /**
       * Refresh plugin data
       * @param  {Array} data list of objects to update
       */
      updateItems: function( data ) {
        if(this.version !== data.version) {
          data = this._migrateData(data);
        }

        data = data.items;

        ASSERT.isArray( data );

        var currentObjHash = {};
        var lastUpdateChecksum = new Date().toString() + Math.random().toString();

        this.objList = this.objList;

        this._gResetMinMaxPositionedXY();

        for ( var i = 0, l = data.length; i < l; i++ ) {
          ASSERT.isPlainObject( data[i] );
          ASSERT.isString( data[ i ].type );
          ASSERT.isPlainObject( data[ i ].attributes );
          ASSERT.isUndefined( currentObjHash[ data[ i ].id ], { msg: 'Expected different id\'s for each object when updating data', } );
          ASSERT( _.isNumber( data[ i ].id ) || _.isString( data[ i ].id ) );
          ASSERT( _.includes( Object.keys( this.types ), data[i].type ), { msg: 'Expected different id\'s for each object when updating data', } );


          var obj;
          var attributeName;
          var rawObj = data[i];

          if ( this.objHash[rawObj.id] ) {
            obj = this.objHash[rawObj.id];
          } else {
            obj = {
              id: rawObj.id,
              type: null,
              statusClassNames: null,
              typeObj: this.types[rawObj.type],
              attributes: {},
              contents: {},
              x: null,
              y: null,
              xCalc: null,
              yCalc: null,
              xCalcTemp: null,
              yCalcTemp: null,
              lastUpdateChecksum: null,
              firstUpdateChecksum: lastUpdateChecksum,
              expiresIn: null,
              rotateDeg: null,
              rotateDegCalcTemp: null,
              timeouts: {},
            };

            this.objHash[rawObj.id] = obj;
            this.objList.push( obj );
          }

          obj.statusClassNames = 'tb-lg-item-content ' + obj.typeObj.className + ' ';
          obj.type = rawObj.type;
          obj.lastUpdateChecksum = lastUpdateChecksum;


          if ( !TB.isEmpty( rawObj.expiresIn ) ) {
            ASSERT.isNumber( rawObj.expiresIn );

            obj.expiresIn = rawObj.expiresIn;

            this._timeoutExpireObject( obj );
          } else {
            obj.expiresIn = null;
          }

          // Update rotateDeg only if it's not in edit mode
          if ( !this.g.editMode ) {
            // Check if `rotateDeg` is defined on raw object. `rotateDeg` are the degrees used to rotate each element clockwise
            if ( !TB.isEmpty( rawObj.rotateDeg ) ) {
              ASSERT.isNumber( rawObj.rotateDeg );

              obj.rotateDeg = rawObj.rotateDeg || obj.rotateDeg;
              obj.rotateDegCalcTemp = rawObj.rotateDeg;
            } else {
              obj.rotateDeg = 0;
              obj.rotateDegCalcTemp = obj.rotateDegCalcTemp || 0;
            }
          }


          for ( attributeName in rawObj.attributes ) {
            ASSERT.isString( rawObj.attributes[ attributeName ] );
            ASSERT( _.includes( this.types[obj.type].attributesNameList, attributeName ), { msg: 'Expected known "attribute" for type "' + obj.type + '" for each object while updating data', } );
            ASSERT( _.includes( this.types[obj.type].attributes[ attributeName ].stateList, rawObj.attributes[ attributeName ] ), { msg: 'Expected known "state" for attribute "' + attributeName + '", type "' + obj.type + '" for each object when updating data', } );

            var statusName = rawObj.attributes[attributeName];

            obj.attributes[attributeName] = statusName || obj.attributes[attributeName];
          }


          for ( attributeName in obj.attributes ) {
            obj.statusClassNames += ' ' + obj.typeObj.attributes[attributeName].stateClassNames[obj.attributes[attributeName]];
          }


          for ( var contentName in rawObj.contents ) {
            ASSERT( _.isString(rawObj.contents[ contentName ]) || _.isNumber(rawObj.contents[ contentName ]) );
            ASSERT( _.includes( this.types[obj.type].contentsNameList, contentName ), { msg: 'Expected known "content" for type "' + obj.type + '" for each object while updating data', } );

            obj.contents[ contentName ] = rawObj.contents[ contentName ];
          }

          if ( this.g.isEnabled && ( obj.lastUpdateChecksum === obj.firstUpdateChecksum || !this.g.editMode ) ) {
            this._gUpdateItemCoordinates( rawObj, obj );
          }

          this._gUpdateMinMaxPositionedXY( obj.x, obj.y );

          currentObjHash[rawObj.id] = obj;
        }

        if ( this.g.isEnabled ) {
          this._gUpdateUnpositionedItemsCoordinates();
          this._d3UpdateWrapper();
          this._d3UpdateBackgroundGrid();
        }

        this._d3UpdateItems();

        if ( this.g.isEnabled && this.s.grid.autoscale && !this.g.editMode ) {
          if( !this.s.grid.autoscaleUnpositionedOnly ) {
            this._gAutoscale();
          } else if ( this.g.hadUnpositionedElements ) {
            this._gAutoscale();
          }
        }
      },
      /**
       * Emit event for listeners
       * @param  {String} eventName name of the dispatched event
       * @param  {*} data      event data
       */
      emit: function( eventName, data ) {
        var event = new CustomEvent( eventName, {
          detail: data,
          bubbles: false,
          cancable: false,
        } );

        this.dispatch( eventName, data );
        this.DOMwrapper.node()
          .dispatchEvent( event );
      },
      /**
       * Get item at given posion in given index table
       * @private
       * @param  {Number} x          x
       * @param  {Number} y          y
       * @param  {indexTable} indexTable index table to search in
       * @return {?Object}            found element at given position
       */
      _gGetItemAtIndex: function( x, y, indexTable ) {
        indexTable[y] = indexTable[y] || [];
        return indexTable[y][x] || null;
      },
      /**
       * Helper function converting degrees to radians
       * @param {Number} deg degrees
       * @return {Number} radians
       **/
      _deg2rad: function(deg) {
        return deg * (Math.PI / 180);
      },
      /**
       * Return array of possible adjacent items
       * @private
       * @param  {Number} x          x
       * @param  {Number} y          y
       * @param  {indexTable} indexTable index table to search in
       * @return {Array}            found elements adjavent to given position
       **/
      _getPossibleAdjacentItemsRelativeToIndex: function( x, y, indexTable) {
        var foundItems = [];
        var diag = Math.floor(Math.sqrt(Math.pow(this.g.itemWidth, 2) + Math.pow(this.g.itemHeight, 2)));
        var xStart = Math.max(0, x - diag);
        var xEnd = x + diag + this.g.itemWidth;
        var yStart = Math.max(0, y - diag);
        var yEnd = y + diag + this.g.itemHeight;

        for(var xTest = xStart; xTest <= xEnd; xTest++) {
          for(var yTest = yStart; yTest <= yEnd; yTest++) {
            if(indexTable[xTest] && indexTable[xTest][yTest] && yTest !== y && xTest !== x) {
              foundItems.push(indexTable[xTest][yTest]);
            }
          }
        }

        return foundItems;
      },
      /**
       * Remove item at given position in given index table
       * @private
       * @param  {Number} x          x
       * @param  {Number} y          y
       * @param  {indexTable} indexTable index table to search in
       * @return {Boolean}            result of delete operator
       */
      _gRemoveItemAtIndex: function( x, y, indexTable ) {
        indexTable[y] = indexTable[y] || [];
        return delete indexTable[y][x];
      },
      /**
       * Set item at given position in given index table
       * @private
       * @param  {Number} x          x
       * @param  {Number} y          x
       * @param  {Object} value      item at this position
       * @param  {indexTable} indexTable indexTable to set in
       * @return {Object}            positioned item
       */
      _gSetItemAtIndex: function( x, y, value, indexTable ) {
        indexTable[y] = indexTable[y] || [];
        indexTable[y][x] = value;
        return value;
      },
      toggleSnapMode: function() {
        if ( this.g.snapMode ) {
          this.disableSnapMode();
        } else {
          this.enableSnapMode();
        }
      },
      enableSnapMode: function() {
        this.g.snapMode = true;

        this.emit( 'tb.lg.toggleSnap', {
          instance: this,
          isSnapMode: true,
        } );

        this.emit( 'tb.lg.enableSnap', {
          instance: this,
        } );
      },
      disableSnapMode: function() {
        this.g.snapMode = false;

        this.emit( 'tb.lg.toggleSnap', {
          instance: this,
          isSnapMode: false,
        } );

        this.emit( 'tb.lg.disableSnap', {
          instance: this,
        } );
      },
      /**
       * Toggle edit mode of the grid
       * @private
       */
      toggleEditMode: function() {
        if ( this.g.editMode ) {
          this.disableEditMode();
        } else {
          this.enableEditMode();
        }
      },
      /**
       * Enable edit mode of the grid
       * @private
       */
      enableEditMode: function() {
        TRACE( 'Add drag behavior' );
        var self = this;

        this.g.editMode = true;

        this.emit( 'tb.lg.toggleEdit', {
          instance: this,
          isEditMode: true,
        } );

        this.emit( 'tb.lg.enableEdit', {
          instance: this,
        } );

        this.DOMitemsContainer
          .selectAll( 'div.tb-lg-item' )
          .on('click.rotateDeg', function() {
            if ( d3.event.defaultPrevented || self.isDragging ) return;

            var obj = self.objHash[ d3.select( this ).data()[0].id ];

            obj.rotateDegCalcTemp += self.s.grid.rotateDegStep;

            self._d3UpdateItems();
          })
          .call( this.g.D3dragItems );

        this.DOMel.classed( 'tb-lg-editing', true );

        if ( !this.disableMenu ) {
          this.DOMnavbar.style( 'display', 'initial' );
          this.DOMnavbar.classed( 'tb-lg-active', true );

          this.DOMbtnSave.attr( 'disabled', null );
          this.DOMbtnSnap.attr( 'disabled', null );
          this.DOMbtnEdit.text( 'Cancel' );
        }

        this.g.indexTableTemp = TB.merge( [], this.g.indexTableAll );

        for ( var i = 0, l = this.objList.length; i < l; i++ ) {
          this.objList[ i ].xCalcTemp = this.objList[ i ].xCalc;
          this.objList[ i ].yCalcTemp = this.objList[ i ].yCalc;
        }
      },
      /**
       * Disable edit mode of the grid
       * @private
       */
      disableEditMode: function() {
        TRACE( 'Remove the drag behavior' );
        this.g.editMode = false;

        this.emit( 'tb.lg.toggleEdit', {
          instance: this,
          isEditMode: false,
        } );

        this.emit( 'tb.lg.disableEdit', {
          instance: this,
        } );

        this.DOMitemsContainer
          .selectAll( 'div.tb-lg-item' )
          .on( '.drag', null )
          .on('click.rotateDeg', null);

        if ( !this.disableMenu ) {
          this.DOMbtnSave.attr( 'disabled', 'disabled' );
          this.DOMbtnEdit.text( 'Edit' );

          this.DOMnavbar.style( 'display', ( this.s.hideInactiveMenu ) ? 'none' : 'initial' );
          this.DOMnavbar.classed( 'tb-lg-active', false );
        }

        this.DOMel.classed( 'tb-lg-editing', false );

        this.g.indexTableTemp = null;

        for ( var i = 0, l = this.objList.length; i < l; i++ ) {
          delete this.objList[ i ].xCalcTemp;
          delete this.objList[ i ].yCalcTemp;
          delete this.objList[ i ].rotateDegCalcTemp;
        }

        this._d3UpdateItems();
      },
      /**
       * Programatically set size of items
       * @public
       */
      setItemsSize: function( height, width ) {
        if ( TB.isNumber( height ) ) {
          this.DOMsliderHeight[0][0].value = TB.limitToRange( height, this.s.grid.minItemHeight, this.s.grid.maxItemHeight );
        }

        if ( TB.isNumber( width ) ) {
          this.DOMsliderWidth[0][0].value = TB.limitToRange( width, this.s.grid.minItemWidth, this.s.grid.maxItemWidth );
        }

        this._gApplyResizeItems();
      },
      /**
       * Programatically set grid zoom
       * @public
       */
      setGridZoom: function( scale ) {
        this.g.zoom.scale( TB.limitToRange( scale, this.s.grid.minZoom, this.s.grid.maxZoom ) );
        this._gZoomCallback();
      },
      /**
       * Save grid coordinates
       * @private
       */
      save: function() {
        ASSERT.isArray( this.g.indexTableTemp );

        var result = [];

        for ( var i = 0, l = this.objList.length; i < l; i++ ) {
          var obj = this.objList[ i ];
          var objCoords = {};

          obj.rotateDeg = ( TB.isEmpty(obj.rotateDegCalcTemp) ) ? obj.rotateDeg : obj.rotateDegCalcTemp;

          objCoords.id = obj.id;
          objCoords.rotateDeg = obj.rotateDeg;

          this._gRemoveItemAtIndex( obj.xCalc, obj.yCalc, this.g.indexTableAll );

          if ( obj.xCalcTemp === obj.xCalc && obj.yCalcTemp === obj.yCalc ) {
            // objCoords.x = obj.x || obj.xCalc || obj.xCalcTemp;
            // objCoords.y = obj.y || obj.yCalc || obj.yCalcTemp;

            if ( TB.isDefined( obj.x ) && TB.isDefined( obj.x ) ) {
              objCoords.x = obj.x;
              objCoords.y = obj.y;
            } else {
              objCoords.x = null;
              objCoords.y = null;
            }
          } else {
            var swapObj = this._gGetItemAtIndex( obj.x, obj.y, this.g.indexTable );

            if ( swapObj === obj ) {
              this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTable );
              this._gRemoveItemAtIndex( obj.x, obj.y, this.g.indexTableAll );
            }

            obj.x = obj.xCalcTemp;
            obj.y = obj.yCalcTemp;
            obj.xCalc = obj.xCalcTemp;
            obj.yCalc = obj.yCalcTemp;

            objCoords.x = obj.x;
            objCoords.y = obj.y;

            this._gSetItemAtIndex( obj.x, obj.y, obj, this.g.indexTable );
            this._gSetItemAtIndex( obj.x, obj.y, obj, this.g.indexTableAll );
          }

          result.push( objCoords );
        }


        this.emit( 'tb.lg.saveData', {
          version: this.version,
          instance: this,
          coordinates: result,
          settings: {
            itemHeight: +this.g.itemHeight,
            itemWidth: +this.g.itemWidth,
            elHeight: parseInt( this.DOMel.style( 'height' ), 10 ),
            opacity: +this.g.opacity,
            zoom: this.g.zoom.scale(),
          },
        } );

        this._d3UpdateItems();
      },
      /**
       * Update items contents
       * @private
       * @param  {Array} objectsD3 array of d3 data
       */
      _d3UpdateItemContents: function( objectsD3 ) {
        return function( d, i ) {
          var objDOM = objectsD3[0][i];

          for ( var contentName in d.contents ) {
            var contentSettings = d.typeObj.contents[contentName];
            var contentDOM = objDOM.querySelector( contentSettings.selector );

            if ( contentSettings.attribute ) {
              contentDOM.setAttribute( contentSettings.attribute, d.contents[ contentName ] );
            } else {
              if ( contentSettings.propertyArr.length === 1 ) {
                contentDOM[ contentSettings.property ] = d.contents[ contentName ];
              } else {
                TB.set( contentDOM, contentSettings.propertyArr, d.contents[contentName] );
              }
            }
          }
        };
      },
      /**
       * Update items DOM
       * @private
       */
      _d3UpdateItems: function() {
        var self = this;
        var objectsD3 = this.DOMitemsContainer
          .selectAll( 'div.tb-lg-item' )
          .data( self.objList, this._returnDatum( 'id' ) );
        var exited = objectsD3.exit().remove();
        var entered = objectsD3.enter()
          .append( 'div' )
          .classed( 'tb-lg-item', true )
          .attr( 'data-tb-lg-id', function( d ) { return d.id; } )
          .append( 'div' )
          .classed( 'tb-lg-item-content', true )
          .html( this._returnDatum( 'typeObj.template' ) );
        var itemNavbar = entered
          .append( 'div' )
          .classed( 'tb-lg-navbar', true );


        objectsD3
          .select( '.tb-lg-item-content' )
          .attr( 'class', this._returnDatum( 'statusClassNames' ) )
          .each( this._d3UpdateItemContents( objectsD3 ) );

        if ( this.g.isEnabled ) {
          itemNavbar
            .append( 'button' )
            .classed( 'tb-lg-btn', true )
            .classed( 'tb-lg-btn-clear', true )
            .text( 'Clear' )
            .on( 'click', this._handlerOnClickBtnClear.bind( this ) );


          objectsD3
            .select( '.tb-lg-btn-clear' )
            .property( 'disabled', function( d ) { return TB.isEmpty( d.x ); } );


          objectsD3
            .style( 'width', TB.toPx( this.g.itemWidth ) )
            .style( 'height', TB.toPx( this.g.itemHeight ) );


          objectsD3
            .style( 'left', function( d ) {
              var x = ( TB.isEmpty( d.xCalcTemp ) ? d.xCalc : d.xCalcTemp );

              return TB.toPx( x  );
            } )
            .style( 'top', function( d ) {
              var y = ( TB.isEmpty( d.yCalcTemp ) ? d.yCalc : d.yCalcTemp );

              return TB.toPx( y );
            } );


            var t = new Date().getTime();

          objectsD3
            .style( 'transform-origin', 'center center' )
            .style( 'transform', function(d) {
              var rotateDeg = ( TB.isEmpty( d.rotateDegCalcTemp ) ? d.rotateDeg : d.rotateDegCalcTemp );
              return 'rotate(' + rotateDeg + 'deg)';
            } );

            var self = this;

            if ( this.s.grid.itemAutoscale ) {
              objectsD3
                .each( function( d, index ) {
                  if ( !d.typeObj.contentScaleSelector ) {
                    return;
                  }

                  var elements = this.querySelectorAll( d.typeObj.contentScaleSelector );

                  ASSERT_PEER(elements.length === 1, { msg: 'Must be exactly one element of option `contentScaleSelector`', });

                  var el = elements[0];

                  setTimeout( function() {
                    var scaleFactor;
                    var scaleFactorX = self.g.itemWidth / el.offsetWidth;
                    var scaleFactorY = self.g.itemHeight / el.offsetHeight;
                    var skip = true;

                    if ( el.clientWidth < el.scrollWidth ) {
                      skip = false;
                      scaleFactorX = self.g.itemWidth / el.scrollWidth;
                    }

                    if ( el.clientHeight < el.scrollHeight ) {
                      skip = false;
                      scaleFactorY = self.g.itemHeight / el.scrollHeight;
                    }

                    scaleFactor = Math.min( scaleFactorX, scaleFactorY ) - 0.05;
                    scaleFactor = Math.min( scaleFactor, 1 );

                    if ( skip ) {
                      return;
                    }

                    d3.selectAll( elements )
                      .style( 'transform', 'scale(' + scaleFactor + ')' )
                      .style( 'transform-origin', 'top left' );
                  }.bind( this ) );
                } );
            }
        }
      },
    };

    TB.classExtend( Livegrid, Dispatcher );

    return Livegrid;

    /**
     * D3 selection
     * @typedef {Array} D3selection
     */
    /**
     * String that is valid CSS selector
     * @typedef {String} DOMSelector
     */
    /**
     * Object that is instance of DOMElement
     * @typedef {Object} DOMElement
     */
    /**
     * @typedef {Object} InitTypeObject
     * @property {String} template HTML template of the item
     * @property {Object.<String,InitContentObject>} contents contents replacement definitions
     * @property {Object.<String,InitAttributeSetting>} attributes attributes definitions
     */
    /**
     * @typedef {Object} InitContentObject
     * @property {DOMSelector} selector selector used to find proper DOM element in item's template
     * @property {PropertyPath} property which property of DOM element to be applied with new content
     */
    /**
     * @typedef {Object} InitAttributeSetting
     * @property {Integer} priority defines which attribute styles are stronger. If two attribute's states set different colors, the attribute with higher priority wins.
     * @property {Object.<String,InitStateSetting>} states states definitions
     */
    /**
     * @typedef {Object} InitStateSetting
     * @property {Object.<DOMSelector,String>} cssjson
     */
    /**
     * @typedef {String} CSSColor
     * @example
     *    rgb( 6,120,155 ); rgba( 6,120,155, 1 ); #131314; #333; royalblue
     */
    /**
     * Two dimensional array containing the indexed items on the grid
     * @typedef {Array} indexTable
     * @example
     * var item = {x: 10, y: 20};
     * var indexTable = [ [] ];
     * indexTable[ y ] = indexTable[ y ] || [];
     * indexTable[ y ][ x ] = item; // Now indexTable[20][10] contains item positioned on this coordinates
     */
});
